<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Analysis Visual Report - my-project</title>
    <style>
      :root {
        --bg-1: #f4f1e8;
        --bg-2: #e4f2ec;
        --ink: #1f2a37;
        --muted: #667085;
        --panel: rgba(255, 255, 255, 0.84);
        --line: rgba(31, 42, 55, 0.15);
        --high: #e76f51;
        --mid: #e9c46a;
        --low: #2a9d8f;
        --external: #94a3b8;
        --accent: #1f6f5c;
        --shadow: 0 24px 48px rgba(15, 23, 42, 0.14);
        --glow: 0 0 18px rgba(231, 111, 81, 0.35);
        --code-bg: rgba(15, 23, 42, 0.95);
      }

      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      body {
        font-family: "Space Grotesk", "Avenir Next", "Futura", "Gill Sans", sans-serif;
        background: radial-gradient(circle at 18% 15%, #fff8eb, transparent 55%),
          radial-gradient(circle at 85% 12%, #dff2f0, transparent 50%),
          linear-gradient(135deg, var(--bg-1), var(--bg-2));
        color: var(--ink);
        min-height: 100vh;
      }

      body::before {
        content: "";
        position: fixed;
        inset: 0;
        background-image: radial-gradient(rgba(31, 42, 55, 0.06) 1px, transparent 1px);
        background-size: 20px 20px;
        pointer-events: none;
        opacity: 0.55;
      }

      .workspace {
        position: relative;
        z-index: 1;
      }

      .workspace-tabs-wrap {
        position: sticky;
        top: 0;
        z-index: 30;
        padding: 0.9rem 1.6rem 0.4rem;
        backdrop-filter: blur(8px);
      }

      .workspace-tabs {
        display: inline-flex;
        align-items: center;
        gap: 0.45rem;
        padding: 0.35rem;
        background: rgba(255, 255, 255, 0.84);
        border-radius: 999px;
        border: 1px solid rgba(255, 255, 255, 0.6);
        box-shadow: 0 10px 24px rgba(15, 23, 42, 0.12);
      }

      .workspace-tab {
        border: none;
        background: transparent;
        border-radius: 999px;
        padding: 0.45rem 0.95rem;
        font-size: 0.76rem;
        font-weight: 600;
        letter-spacing: 0.1em;
        text-transform: uppercase;
        color: var(--muted);
        cursor: pointer;
        transition: background 0.2s ease, color 0.2s ease, transform 0.2s ease;
      }

      .workspace-tab:hover {
        color: var(--accent);
        background: rgba(31, 111, 92, 0.08);
        transform: translateY(-1px);
      }

      .workspace-tab.is-active {
        color: #ffffff;
        background: var(--accent);
      }

      .workspace-tab:focus-visible {
        outline: 2px solid var(--accent);
        outline-offset: 2px;
      }

      .workspace-panel {
        display: none;
      }

      .workspace-panel.is-active {
        display: block;
      }

      .app {
        display: grid;
        grid-template-columns: 240px minmax(0, 1fr) 320px;
        gap: 1.5rem;
        padding: 1.6rem;
        min-height: calc(100vh - 5.5rem);
      }

      .nav-panel {
        position: relative;
        background: var(--panel);
        border-radius: 1.4rem;
        box-shadow: var(--shadow);
        border: 1px solid rgba(255, 255, 255, 0.5);
        display: flex;
        flex-direction: column;
        overflow: hidden;
        min-height: 0;
      }

      .nav-header {
        padding: 1rem 1rem 0.6rem;
        border-bottom: 1px solid rgba(31, 42, 55, 0.08);
      }

      .nav-title {
        font-size: 0.82rem;
        text-transform: uppercase;
        letter-spacing: 0.2em;
        color: var(--muted);
      }

      .nav-subtitle {
        font-size: 0.9rem;
        font-weight: 600;
        margin-top: 0.35rem;
      }

      .nav-body {
        flex: 1;
        overflow: auto;
        padding: 0.5rem 0.4rem 0.8rem;
      }

      .nav-footer {
        padding: 0.6rem 1rem 1rem;
        font-size: 0.7rem;
        color: var(--muted);
        display: flex;
        flex-direction: column;
        gap: 0.6rem;
      }

      .nav-footer-text {
        line-height: 1.4;
      }

      .settings {
        display: flex;
        flex-direction: column;
        gap: 0.4rem;
      }

      .settings-title {
        font-size: 0.62rem;
        text-transform: uppercase;
        letter-spacing: 0.16em;
        color: var(--muted);
      }

      .settings-row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.5rem;
        font-size: 0.72rem;
        color: var(--ink);
      }

      .settings-select {
        border: 1px solid rgba(31, 42, 55, 0.18);
        border-radius: 0.6rem;
        padding: 0.2rem 0.4rem;
        background: rgba(255, 255, 255, 0.7);
        font-size: 0.72rem;
        color: inherit;
      }

      .tree-root,
      .tree-group {
        list-style: none;
        padding-left: 0.9rem;
        display: flex;
        flex-direction: column;
        gap: 0.2rem;
      }

      .tree-root {
        padding-left: 0.4rem;
      }

      .tree-item {
        display: flex;
        flex-direction: column;
        gap: 0.2rem;
      }

      .tree-row {
        display: flex;
        align-items: center;
        gap: 0.2rem;
      }

      .tree-toggle {
        border: none;
        background: transparent;
        color: var(--muted);
        width: 1.2rem;
        height: 1.2rem;
        line-height: 1;
        font-size: 0.75rem;
        cursor: pointer;
        padding: 0;
      }

      .tree-toggle.is-hidden {
        visibility: hidden;
      }

      .tree-button {
        border: none;
        background: transparent;
        text-align: left;
        width: 100%;
        padding: 0.25rem 0.4rem;
        border-radius: 0.5rem;
        font-size: 0.78rem;
        color: var(--ink);
        cursor: pointer;
        transition: background 0.2s ease, color 0.2s ease;
      }

      .tree-button:hover {
        background: rgba(31, 111, 92, 0.1);
      }

      .tree-button.is-active {
        background: rgba(31, 111, 92, 0.18);
        color: var(--accent);
        font-weight: 600;
      }

      .tree-button.is-disabled {
        color: var(--muted);
        cursor: default;
      }

      .tree-file {
        font-size: 0.75rem;
        color: var(--muted);
      }

      .tree-item.is-collapsed > .tree-group {
        display: none;
      }

      .tree-empty {
        font-size: 0.78rem;
        color: var(--muted);
        padding: 0.6rem;
      }

      .map-surface {
        position: relative;
        background: var(--panel);
        border-radius: 1.6rem;
        box-shadow: var(--shadow);
        overflow: hidden;
        border: 1px solid rgba(255, 255, 255, 0.5);
      }

      .map-shell {
        position: relative;
        width: 100%;
        height: 100%;
        min-height: 640px;
        animation: fadeRise 700ms ease both;
      }

      #map {
        width: 100%;
        height: 100%;
        display: block;
        cursor: grab;
      }

      #map.grabbing {
        cursor: grabbing;
      }

      .breadcrumbs {
        position: absolute;
        top: 1.2rem;
        left: 1.2rem;
        display: flex;
        align-items: center;
        gap: 0.4rem;
        font-size: 0.72rem;
        text-transform: uppercase;
        letter-spacing: 0.12em;
        color: var(--muted);
        z-index: 2;
      }

      .crumb {
        border: none;
        background: rgba(255, 255, 255, 0.85);
        padding: 0.35rem 0.6rem;
        border-radius: 999px;
        font-size: 0.7rem;
        text-transform: uppercase;
        letter-spacing: 0.12em;
        color: var(--muted);
        cursor: pointer;
        transition: color 0.2s ease, background 0.2s ease;
      }

      .crumb.is-active {
        background: rgba(31, 111, 92, 0.15);
        color: var(--accent);
        cursor: default;
      }

      .crumb-sep {
        color: rgba(31, 42, 55, 0.3);
      }

      .dashboard {
        position: absolute;
        top: 3.6rem;
        left: 1.2rem;
        display: grid;
        gap: 0.6rem;
        z-index: 2;
        max-width: 240px;
      }

      .dashboard-item {
        background: rgba(255, 255, 255, 0.9);
        border-radius: 0.9rem;
        padding: 0.6rem 0.75rem;
        border: 1px solid rgba(31, 42, 55, 0.08);
        box-shadow: 0 10px 24px rgba(15, 23, 42, 0.12);
      }

      .dash-label {
        display: block;
        font-size: 0.6rem;
        text-transform: uppercase;
        letter-spacing: 0.18em;
        color: var(--muted);
        margin-bottom: 0.25rem;
      }

      .dash-value {
        font-size: 0.9rem;
        font-weight: 600;
      }

      .dash-distribution {
        display: flex;
        gap: 0.5rem;
        flex-wrap: wrap;
        font-size: 0.78rem;
        color: var(--muted);
      }

      .dash-chip {
        padding: 0.2rem 0.45rem;
        border-radius: 999px;
        background: rgba(31, 42, 55, 0.06);
        color: var(--ink);
      }

      .search-hint {
        position: absolute;
        top: 1.2rem;
        right: 1.2rem;
        background: rgba(255, 255, 255, 0.85);
        border-radius: 999px;
        padding: 0.35rem 0.7rem;
        font-size: 0.68rem;
        text-transform: uppercase;
        letter-spacing: 0.18em;
        color: var(--muted);
        z-index: 2;
      }

      .map-legend {
        position: absolute;
        left: 1.2rem;
        bottom: 1.4rem;
        display: flex;
        gap: 0.6rem;
        align-items: center;
        font-size: 0.7rem;
        color: var(--muted);
        z-index: 2;
      }

      .legend-item {
        display: flex;
        align-items: center;
        gap: 0.3rem;
      }

      .swatch {
        width: 0.7rem;
        height: 0.7rem;
        border-radius: 4px;
        display: inline-block;
      }

      .swatch.low {
        background: var(--low);
      }

      .swatch.mid {
        background: var(--mid);
      }

      .swatch.high {
        background: var(--high);
      }

      .swatch.external {
        background: var(--external);
        border-radius: 50%;
      }

      .map-hint {
        position: absolute;
        right: 1.2rem;
        bottom: 1.4rem;
        font-size: 0.7rem;
        color: var(--muted);
        text-align: right;
        max-width: 220px;
        z-index: 2;
      }

      .map-controls {
        position: absolute;
        top: 4.2rem;
        right: 1.2rem;
        display: flex;
        flex-direction: column;
        gap: 0.4rem;
        z-index: 2;
      }

      .control-button {
        border: 1px solid rgba(31, 42, 55, 0.12);
        background: rgba(255, 255, 255, 0.9);
        color: var(--ink);
        border-radius: 0.7rem;
        padding: 0.35rem 0.6rem;
        font-size: 0.8rem;
        font-weight: 600;
        min-width: 2.6rem;
        cursor: pointer;
        box-shadow: 0 10px 24px rgba(15, 23, 42, 0.12);
        transition: transform 0.2s ease, background 0.2s ease;
      }

      .control-button:hover {
        background: #ffffff;
        transform: translateY(-1px);
      }

      .control-button:active {
        transform: translateY(0);
      }

      .detail-panel {
        display: flex;
        flex-direction: column;
      }

      .detail-card {
        background: rgba(255, 255, 255, 0.88);
        border-radius: 1.4rem;
        padding: 1.2rem;
        border: 1px solid rgba(255, 255, 255, 0.6);
        box-shadow: var(--shadow);
        display: flex;
        flex-direction: column;
        gap: 1rem;
        min-height: 320px;
      }

      .detail-title {
        font-size: 1.1rem;
        font-weight: 600;
      }

      .detail-label {
        font-size: 0.62rem;
        text-transform: uppercase;
        letter-spacing: 0.16em;
        color: var(--muted);
        margin-bottom: 0.3rem;
      }

      .detail-score {
        display: inline-flex;
        align-items: center;
        gap: 0.4rem;
        font-size: 0.9rem;
        font-weight: 600;
        padding: 0.2rem 0.65rem;
        border-radius: 999px;
        background: rgba(31, 42, 55, 0.06);
      }

      .detail-score.score-high {
        color: #ffffff;
        background: var(--high);
      }

      .detail-score.score-medium {
        color: #1f2a37;
        background: var(--mid);
      }

      .detail-score.score-low {
        color: #ffffff;
        background: var(--low);
      }

      .detail-list {
        list-style: none;
        display: flex;
        flex-direction: column;
        gap: 0.4rem;
        font-size: 0.82rem;
        color: var(--ink);
      }

      .detail-list li {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 0.5rem;
      }

      .detail-list li.detail-doc-item {
        justify-content: flex-start;
      }

      .detail-link {
        color: var(--accent);
        text-decoration: none;
        font-weight: 600;
        word-break: break-word;
      }

      .detail-link:hover {
        text-decoration: underline;
      }

      .detail-pill {
        padding: 0.2rem 0.6rem;
        border-radius: 999px;
        background: rgba(31, 42, 55, 0.06);
        font-size: 0.7rem;
        text-transform: uppercase;
        letter-spacing: 0.1em;
        color: var(--muted);
      }

      .detail-value {
        font-size: 0.78rem;
        color: var(--muted);
        max-width: 160px;
        text-align: right;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }

      .report-shell {
        margin: 0 1.6rem 1.6rem;
        padding: 1.4rem;
        border-radius: 1.5rem;
        background: var(--panel);
        border: 1px solid rgba(255, 255, 255, 0.6);
        box-shadow: var(--shadow);
        min-height: calc(100vh - 8rem);
        display: flex;
        flex-direction: column;
        gap: 1rem;
      }

      .report-head {
        display: flex;
        align-items: flex-start;
        justify-content: space-between;
        gap: 1rem;
      }

      .report-kicker {
        font-size: 0.68rem;
        text-transform: uppercase;
        letter-spacing: 0.18em;
        color: var(--muted);
        margin-bottom: 0.4rem;
      }

      .report-title {
        font-size: 1.35rem;
        line-height: 1.25;
      }

      .report-subtitle {
        margin-top: 0.45rem;
        font-size: 0.86rem;
        color: var(--muted);
        line-height: 1.5;
        max-width: 72ch;
      }

      .report-raw-link {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        text-decoration: none;
        border-radius: 999px;
        padding: 0.45rem 0.8rem;
        font-size: 0.74rem;
        text-transform: uppercase;
        letter-spacing: 0.1em;
        font-weight: 600;
        color: var(--accent);
        border: 1px solid rgba(31, 111, 92, 0.3);
        background: rgba(31, 111, 92, 0.06);
      }

      .report-raw-link:hover {
        background: rgba(31, 111, 92, 0.14);
      }

      .report-status {
        padding: 0.9rem 1rem;
        border-radius: 0.9rem;
        font-size: 0.82rem;
        color: var(--muted);
        background: rgba(31, 42, 55, 0.04);
        border: 1px solid rgba(31, 42, 55, 0.08);
      }

      .report-content {
        background: rgba(255, 255, 255, 0.88);
        border: 1px solid rgba(31, 42, 55, 0.08);
        border-radius: 1rem;
        padding: 1.1rem 1.2rem;
        overflow: auto;
        line-height: 1.6;
        font-size: 0.88rem;
      }

      .report-content h1,
      .report-content h2,
      .report-content h3,
      .report-content h4 {
        margin-top: 1.4rem;
        margin-bottom: 0.6rem;
        line-height: 1.35;
      }

      .report-content h1 {
        font-size: 1.45rem;
      }

      .report-content h2 {
        font-size: 1.2rem;
      }

      .report-content h3 {
        font-size: 1.05rem;
      }

      .report-content p,
      .report-content blockquote,
      .report-content ul,
      .report-content ol,
      .report-content table,
      .report-content pre,
      .report-content hr {
        margin-bottom: 0.8rem;
      }

      .report-content ul,
      .report-content ol {
        padding-left: 1.2rem;
      }

      .report-content blockquote {
        border-left: 4px solid rgba(31, 111, 92, 0.35);
        background: rgba(31, 111, 92, 0.05);
        border-radius: 0.6rem;
        padding: 0.65rem 0.75rem;
        color: var(--ink);
      }

      .report-content code {
        font-family: "JetBrains Mono", "Fira Code", "Menlo", "Consolas", monospace;
        background: rgba(15, 23, 42, 0.08);
        border-radius: 0.35rem;
        padding: 0.05rem 0.3rem;
      }

      .report-content .report-code-block {
        border-radius: 0.9rem;
        overflow: hidden;
        border: 1px solid rgba(15, 23, 42, 0.2);
        background: var(--code-bg);
      }

      .report-content .report-code-title {
        display: block;
        padding: 0.35rem 0.65rem;
        font-size: 0.68rem;
        letter-spacing: 0.1em;
        text-transform: uppercase;
        color: rgba(226, 232, 240, 0.88);
        border-bottom: 1px solid rgba(148, 163, 184, 0.3);
      }

      .report-content .report-code-block pre {
        margin: 0;
        overflow: auto;
        padding: 0.85rem;
      }

      .report-content .report-code-block pre code {
        display: block;
        background: transparent;
        color: #e2e8f0;
        padding: 0;
        white-space: pre;
      }

      .report-content table {
        border-collapse: collapse;
        width: 100%;
      }

      .report-content th,
      .report-content td {
        border: 1px solid rgba(31, 42, 55, 0.14);
        padding: 0.45rem 0.55rem;
        vertical-align: top;
      }

      .report-content th {
        background: rgba(31, 42, 55, 0.08);
      }

      .report-content a {
        color: var(--accent);
      }

      [data-theme="dark"] .crumb,
      [data-theme="dark"] .dashboard-item,
      [data-theme="dark"] .search-hint,
      [data-theme="dark"] .control-button,
      [data-theme="dark"] .detail-card,
      [data-theme="dark"] .workspace-tabs,
      [data-theme="dark"] .report-shell,
      [data-theme="dark"] .report-content {
        background: rgba(30, 41, 59, 0.9);
        border-color: rgba(148, 163, 184, 0.16);
        box-shadow: 0 10px 24px rgba(2, 6, 23, 0.55);
        color: var(--ink);
      }

      [data-theme="dark"] .control-button:hover {
        background: rgba(51, 65, 85, 0.95);
      }

      [data-theme="dark"] .crumb-sep {
        color: rgba(226, 232, 240, 0.35);
      }

      [data-theme="dark"] .dash-chip,
      [data-theme="dark"] .detail-pill {
        background: rgba(226, 232, 240, 0.12);
      }

      [data-theme="dark"] .detail-link {
        color: #7dd3fc;
      }

      [data-theme="dark"] .workspace-tab.is-active {
        color: #0f172a;
        background: #7dd3fc;
      }

      [data-theme="dark"] .report-status {
        background: rgba(148, 163, 184, 0.12);
        border-color: rgba(148, 163, 184, 0.22);
      }

      [data-theme="dark"] .report-content code {
        background: rgba(148, 163, 184, 0.18);
      }

      [data-theme="dark"] .report-content th {
        background: rgba(148, 163, 184, 0.2);
      }

      .map-node {
        cursor: pointer;
        transition: transform 0.2s ease, filter 0.2s ease;
      }

      .map-node:hover {
        filter: drop-shadow(0 12px 20px rgba(15, 23, 42, 0.18));
        transform: translateY(-1px);
      }

      .map-node rect {
        stroke: rgba(255, 255, 255, 0.7);
        stroke-width: 1;
      }

      .map-node.node-score-high rect {
        fill: var(--high);
      }

      .map-node.node-score-medium rect {
        fill: var(--mid);
      }

      .map-node.node-score-low rect {
        fill: var(--low);
      }

      .map-node text {
        font-size: 10px;
        text-anchor: middle;
        pointer-events: none;
        font-family: "Avenir Next", "Futura", "Gill Sans", sans-serif;
        font-weight: 500;
      }

      .map-node.node-score-high text,
      .map-node.node-score-low text {
        fill: #fdfbf6;
      }

      .map-node.node-score-medium text {
        fill: #1f2a37;
      }

      .map-node.node-selected rect {
        stroke: #ffffff;
        stroke-width: 2.2;
        filter: drop-shadow(var(--glow));
      }

      .external-node circle {
        fill: rgba(148, 163, 184, 0.4);
        stroke: rgba(148, 163, 184, 0.8);
        stroke-width: 1;
      }

      .external-node text {
        font-size: 10px;
        fill: rgba(31, 42, 55, 0.7);
        text-anchor: middle;
        pointer-events: none;
        font-family: "Avenir Next", "Futura", "Gill Sans", sans-serif;
        font-weight: 500;
      }

      .edge {
        fill: none;
        stroke: rgba(31, 42, 55, 0.18);
        stroke-width: 1;
      }

      .edge.edge-focus {
        stroke: rgba(231, 111, 81, 0.6);
        stroke-width: 1.6;
      }

      .edge.external-edge {
        stroke: rgba(148, 163, 184, 0.7);
        stroke-dasharray: 4 6;
      }

      .tooltip {
        position: fixed;
        pointer-events: none;
        background: #111827;
        color: #f9fafb;
        border-radius: 0.6rem;
        padding: 0.6rem 0.7rem;
        font-size: 0.72rem;
        line-height: 1.35;
        box-shadow: 0 12px 28px rgba(15, 23, 42, 0.3);
        opacity: 0;
        transform: translateY(8px);
        transition: opacity 0.15s ease, transform 0.15s ease;
        z-index: 10;
        max-width: 240px;
      }

      .tooltip strong {
        display: block;
        margin-bottom: 0.3rem;
        font-size: 0.78rem;
      }

      .palette {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: flex-start;
        justify-content: center;
        padding-top: 12vh;
        z-index: 20;
      }

      .palette.is-hidden {
        display: none;
      }

      .palette-backdrop {
        position: absolute;
        inset: 0;
        background: rgba(15, 23, 42, 0.4);
        backdrop-filter: blur(6px);
      }

      .palette-card {
        position: relative;
        z-index: 1;
        width: min(520px, 92vw);
        background: #ffffff;
        border-radius: 1.2rem;
        padding: 1rem;
        box-shadow: var(--shadow);
        display: flex;
        flex-direction: column;
        gap: 0.8rem;
      }

      .palette-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-size: 0.72rem;
        text-transform: uppercase;
        letter-spacing: 0.16em;
        color: var(--muted);
      }

      .palette-input {
        border: 1px solid rgba(31, 42, 55, 0.18);
        border-radius: 0.9rem;
        padding: 0.7rem 0.9rem;
        font-size: 0.95rem;
        font-family: inherit;
      }

      .palette-results {
        display: flex;
        flex-direction: column;
        gap: 0.4rem;
        max-height: 280px;
        overflow-y: auto;
      }

      .palette-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0.6rem 0.7rem;
        border-radius: 0.8rem;
        cursor: pointer;
        border: 1px solid transparent;
        transition: background 0.2s ease, border 0.2s ease;
      }

      .palette-item:hover,
      .palette-item.is-active {
        background: rgba(31, 111, 92, 0.08);
        border-color: rgba(31, 111, 92, 0.25);
      }

      .palette-title {
        font-size: 0.88rem;
      }

      .palette-meta {
        display: flex;
        align-items: center;
        gap: 0.4rem;
        font-size: 0.65rem;
        text-transform: uppercase;
        letter-spacing: 0.14em;
        color: var(--muted);
      }

      .palette-score {
        padding: 0.1rem 0.4rem;
        border-radius: 999px;
        background: rgba(31, 42, 55, 0.08);
        font-size: 0.6rem;
        color: var(--ink);
      }

      .palette-score.score-high {
        background: rgba(231, 111, 81, 0.2);
        color: #b6472e;
      }

      .palette-score.score-medium {
        background: rgba(233, 196, 106, 0.3);
        color: #8a6d1f;
      }

      .palette-score.score-low {
        background: rgba(42, 157, 143, 0.2);
        color: #1c6f63;
      }

      .palette-empty {
        font-size: 0.8rem;
        color: var(--muted);
        text-align: center;
        padding: 1rem 0.5rem;
      }

      @keyframes fadeRise {
        0% {
          opacity: 0;
          transform: translateY(12px);
        }
        100% {
          opacity: 1;
          transform: translateY(0);
        }
      }

      @media (max-width: 1024px) {
        .workspace-tabs-wrap {
          padding: 0.8rem 1.1rem 0.4rem;
        }

        .app {
          grid-template-columns: 1fr;
        }

        .map-surface {
          order: 1;
        }

        .nav-panel {
          order: 2;
        }

        .detail-panel {
          order: 3;
        }

        .detail-card {
          width: 100%;
        }

        .report-shell {
          margin: 0 1.1rem 1.1rem;
        }
      }

      @media (max-width: 720px) {
        .workspace-tabs-wrap {
          padding: 0.7rem 0.8rem 0.35rem;
        }

        .workspace-tabs {
          width: 100%;
          justify-content: space-between;
        }

        .workspace-tab {
          flex: 1;
        }

        .app {
          padding: 1.1rem;
        }

        .map-shell {
          min-height: 520px;
        }

        .dashboard {
          max-width: 200px;
        }

        .map-hint {
          max-width: 160px;
        }

        .report-shell {
          margin: 0 0.8rem 0.9rem;
          padding: 1rem;
          min-height: calc(100vh - 7rem);
        }

        .report-head {
          flex-direction: column;
        }
      }
    </style>
  </head>
  <body>
    <div class="workspace">
      <div class="workspace-tabs-wrap">
        <div class="workspace-tabs" id="workspace-tabs" role="tablist" aria-label="Analysis views">
          <button
            type="button"
            class="workspace-tab is-active"
            id="tab-visual"
            role="tab"
            aria-selected="true"
            aria-controls="panel-visual"
            tabindex="0"
            data-tab="visual"
          >
            Leverage Map
          </button>
          <button
            type="button"
            class="workspace-tab"
            id="tab-report"
            role="tab"
            aria-selected="false"
            aria-controls="panel-report"
            tabindex="-1"
            data-tab="report"
          >
            Detailed Report
          </button>
        </div>
      </div>

      <section
        class="workspace-panel is-active"
        id="panel-visual"
        role="tabpanel"
        aria-labelledby="tab-visual"
      >
        <div class="app">
          <aside class="nav-panel">
        <div class="nav-header">
          <div class="nav-title" id="nav-title">Source Tree</div>
          <div class="nav-subtitle" id="nav-subtitle">Packages & Files</div>
        </div>
        <div class="nav-body" id="source-tree"></div>
        <div class="nav-footer" id="nav-footer">
          <div class="nav-footer-text" id="nav-footer-text">Select a source to focus the map.</div>
          <div class="settings" id="settings">
            <div class="settings-title" id="settings-title">Settings</div>
            <label class="settings-row" for="theme-select">
              <span id="settings-theme-label">Theme</span>
              <select class="settings-select" id="theme-select">
                <option id="theme-option-light" value="light">Light</option>
                <option id="theme-option-dark" value="dark">Dark</option>
              </select>
            </label>
            <label class="settings-row" for="locale-select">
              <span id="settings-locale-label">Locale</span>
              <select class="settings-select" id="locale-select">
                <option id="locale-option-en" value="en">English</option>
                <option id="locale-option-ja" value="ja">日本語</option>
              </select>
            </label>
          </div>
        </div>
          </aside>
          <main class="map-surface">
        <div class="map-shell">
          <div class="breadcrumbs" id="breadcrumbs"></div>
          <div class="dashboard" id="dashboard">
            <div class="dashboard-item">
              <span class="dash-label" id="dash-overall-risk-label">Overall System Risk</span>
              <div class="dash-value" id="overall-risk">-</div>
            </div>
            <div class="dashboard-item">
              <span class="dash-label" id="dash-hotspot-label">Hotspot Distribution</span>
              <div class="dash-distribution" id="hotspot-distribution"></div>
            </div>
            <div class="dashboard-item">
              <span class="dash-label" id="dash-primary-label">Primary Leverage Driver</span>
              <div class="dash-value" id="primary-driver">-</div>
            </div>
          </div>
          <div class="search-hint" id="search-hint">Search: Cmd + K / Ctrl + K</div>
          <div class="map-controls" id="map-controls">
            <button
              type="button"
              class="control-button"
              data-action="zoom-in"
              aria-label="Zoom in"
              title="Zoom in"
            >
              +
            </button>
            <button
              type="button"
              class="control-button"
              data-action="zoom-out"
              aria-label="Zoom out"
              title="Zoom out"
            >
              -
            </button>
            <button
              type="button"
              class="control-button"
              data-action="reset"
              aria-label="Reset view"
              title="Reset view"
              id="reset-button"
            >
              Reset
            </button>
          </div>
          <svg id="map" role="img" aria-label="Leverage dependency map"></svg>
          <div class="map-legend">
            <div class="legend-item">
              <span class="swatch low"></span><span id="legend-low">Low</span>
            </div>
            <div class="legend-item">
              <span class="swatch mid"></span><span id="legend-medium">Medium</span>
            </div>
            <div class="legend-item">
              <span class="swatch high"></span><span id="legend-high">High</span>
            </div>
            <div class="legend-item">
              <span class="swatch external"></span><span id="legend-external">External</span>
            </div>
          </div>
          <div class="map-hint" id="map-hint">
            Double-click a node to zoom in. Drag to pan. Scroll or use + / - to zoom.
          </div>
        </div>
          </main>
          <aside class="detail-panel">
        <div class="detail-card">
          <div>
            <div class="detail-label" id="detail-selected-label">Selected Node</div>
            <div class="detail-title" id="detail-title">-</div>
          </div>
          <div>
            <div class="detail-label" id="detail-score-label">Leverage Score</div>
            <div class="detail-score" id="detail-score">-</div>
          </div>
          <div>
            <div class="detail-label" id="detail-metrics-label">Metrics</div>
            <ul class="detail-list" id="detail-metrics"></ul>
          </div>
          <div>
            <div class="detail-label" id="detail-docs-label">Class Detail Reports</div>
            <ul class="detail-list" id="detail-docs"></ul>
          </div>
          <div>
            <div class="detail-label" id="detail-reasons-label">Reasons</div>
            <ul class="detail-list" id="detail-reasons"></ul>
          </div>
          <div>
            <div class="detail-label" id="detail-connections-label">Connected Nodes</div>
            <ul class="detail-list" id="detail-connections"></ul>
          </div>
        </div>
          </aside>
        </div>
      </section>

      <section class="workspace-panel" id="panel-report" role="tabpanel" aria-labelledby="tab-report" hidden>
        <div class="report-shell">
          <div class="report-head">
            <div>
              <div class="report-kicker" id="report-kicker">Analysis Report</div>
              <h1 class="report-title" id="report-title">Detailed Summary</h1>
              <p class="report-subtitle" id="report-subtitle">
                Use this tab to read a plain-language summary. Focus on branch guards,
                representative paths, and called methods.
              </p>
            </div>
            <a
              class="report-raw-link"
              id="report-raw-link"
              href="report.md"
              target="_blank"
              rel="noopener noreferrer"
              >Open Raw Markdown</a
            >
          </div>
          <div class="report-status" id="report-status">Loading report...</div>
          <article class="report-content" id="report-content" hidden></article>
        </div>
      </section>
    </div>

    <div class="palette is-hidden" id="palette">
      <div class="palette-backdrop" id="palette-backdrop"></div>
      <div class="palette-card" role="dialog" aria-modal="true">
        <div class="palette-header">
          <span id="palette-title">Search packages or files</span>
          <span id="palette-hint">Esc to close</span>
        </div>
        <input
          id="palette-input"
          class="palette-input"
          type="text"
          placeholder="Type a package or file name"
          autocomplete="off"
        />
        <div class="palette-results" id="palette-results"></div>
      </div>
    </div>

    <div class="tooltip" id="tooltip"></div>

    <script type="application/json" id="analysis-data">
{"classEdges":[{"from":"com.example.legacy.PaymentService","to":"com.example.legacy.PaymentService.Payment","weight":7},{"from":"com.example.legacy.PaymentService","to":"com.example.legacy.PaymentService.GatewayResponse","weight":6},{"from":"com.example.legacy.PaymentService","to":"com.example.legacy.PaymentService.PaymentRepository","weight":5},{"from":"com.example.legacy.PaymentService","to":"com.example.legacy.PaymentService.NotificationService","weight":2},{"from":"com.example.legacy.PaymentService","to":"com.example.legacy.PaymentService.PaymentResult","weight":2},{"from":"com.example.legacy.PaymentService","to":"com.example.legacy.PaymentService.RefundResult","weight":2},{"from":"com.example.legacy.PaymentService","to":"com.example.legacy.PaymentService.PaymentGateway","weight":2},{"from":"com.example.legacy.MessageService","to":"com.example.legacy.util.StringUtil","weight":3},{"from":"com.example.legacy.service.OrderService","to":"com.example.legacy.service.OrderRepository","weight":4},{"from":"com.example.legacy.service.OrderService","to":"com.example.legacy.service.NotificationService","weight":2},{"from":"com.example.legacy.service.OrderService","to":"com.example.legacy.service.Order","weight":2},{"from":"com.example.legacy.ComplexInvoiceService","to":"com.example.legacy.ComplexInvoiceService.InvoiceItem","weight":6},{"from":"com.example.legacy.ComplexInvoiceService","to":"com.example.legacy.ComplexInvoiceService.CalculationResult","weight":2},{"from":"com.example.legacy.ComplexInvoiceService","to":"com.example.legacy.SimpleCustomerData","weight":2},{"from":"com.example.legacy.CustomerService","to":"com.example.legacy.CustomerService.Customer","weight":6}],"classes":[{"complexityAvg":16.5,"complexityMax":32,"complexitySum":33,"detailLink":"src/main/java/com/example/legacy/ComplexInvoiceService.html","filePath":"src/main/java/com/example/legacy/ComplexInvoiceService.java","id":"com.example.legacy.ComplexInvoiceService","loc":225,"methodCount":2,"packageName":"com.example.legacy","simpleName":"ComplexInvoiceService"},{"complexityAvg":1.0,"complexityMax":1,"complexitySum":7,"detailLink":"src/main/java/com/example/legacy/ComplexInvoiceService_InvoiceItem.html","filePath":"src/main/java/com/example/legacy/ComplexInvoiceService.java","id":"com.example.legacy.ComplexInvoiceService.InvoiceItem","loc":43,"methodCount":7,"packageName":"com.example.legacy","simpleName":"InvoiceItem"},{"complexityAvg":0.0,"complexityMax":0,"complexitySum":0,"detailLink":"src/main/java/com/example/legacy/ComplexInvoiceService_CalculationResult.html","filePath":"src/main/java/com/example/legacy/ComplexInvoiceService.java","id":"com.example.legacy.ComplexInvoiceService.CalculationResult","loc":7,"methodCount":0,"packageName":"com.example.legacy","simpleName":"CalculationResult"},{"complexityAvg":2.5714285714285716,"complexityMax":5,"complexitySum":18,"detailLink":"src/main/java/com/example/legacy/CustomerService.html","filePath":"src/main/java/com/example/legacy/CustomerService.java","id":"com.example.legacy.CustomerService","loc":147,"methodCount":7,"packageName":"com.example.legacy","simpleName":"CustomerService"},{"complexityAvg":1.0,"complexityMax":1,"complexitySum":11,"detailLink":"src/main/java/com/example/legacy/CustomerService_Customer.html","filePath":"src/main/java/com/example/legacy/CustomerService.java","id":"com.example.legacy.CustomerService.Customer","loc":56,"methodCount":11,"packageName":"com.example.legacy","simpleName":"Customer"},{"complexityAvg":1.1111111111111112,"complexityMax":2,"complexitySum":10,"detailLink":"src/main/java/com/example/legacy/DynamicTestPatterns.html","filePath":"src/main/java/com/example/legacy/DynamicTestPatterns.java","id":"com.example.legacy.DynamicTestPatterns","loc":81,"methodCount":9,"packageName":"com.example.legacy","simpleName":"DynamicTestPatterns"},{"complexityAvg":1.0,"complexityMax":1,"complexitySum":4,"detailLink":"src/main/java/com/example/legacy/ICustomerRepository.html","filePath":"src/main/java/com/example/legacy/ICustomerRepository.java","id":"com.example.legacy.ICustomerRepository","loc":33,"methodCount":4,"packageName":"com.example.legacy","simpleName":"ICustomerRepository"},{"complexityAvg":2.0,"complexityMax":3,"complexitySum":4,"detailLink":"src/main/java/com/example/legacy/MessageService.html","filePath":"src/main/java/com/example/legacy/MessageService.java","id":"com.example.legacy.MessageService","loc":13,"methodCount":2,"packageName":"com.example.legacy","simpleName":"MessageService"},{"complexityAvg":1.0,"complexityMax":1,"complexitySum":3,"detailLink":"src/main/java/com/example/legacy/OrderProcessingService.html","filePath":"src/main/java/com/example/legacy/OrderProcessingService.java","id":"com.example.legacy.OrderProcessingService","loc":19,"methodCount":3,"packageName":"com.example.legacy","simpleName":"OrderProcessingService"},{"complexityAvg":3.0,"complexityMax":7,"complexitySum":18,"detailLink":"src/main/java/com/example/legacy/PaymentService.html","filePath":"src/main/java/com/example/legacy/PaymentService.java","id":"com.example.legacy.PaymentService","loc":300,"methodCount":6,"packageName":"com.example.legacy","simpleName":"PaymentService"},{"complexityAvg":1.0,"complexityMax":1,"complexitySum":2,"detailLink":"src/main/java/com/example/legacy/PaymentService_PaymentGateway.html","filePath":"src/main/java/com/example/legacy/PaymentService.java","id":"com.example.legacy.PaymentService.PaymentGateway","loc":5,"methodCount":2,"packageName":"com.example.legacy","simpleName":"PaymentGateway"},{"complexityAvg":1.0,"complexityMax":1,"complexitySum":2,"detailLink":"src/main/java/com/example/legacy/PaymentService_NotificationService.html","filePath":"src/main/java/com/example/legacy/PaymentService.java","id":"com.example.legacy.PaymentService.NotificationService","loc":5,"methodCount":2,"packageName":"com.example.legacy","simpleName":"NotificationService"},{"complexityAvg":1.0,"complexityMax":1,"complexitySum":4,"detailLink":"src/main/java/com/example/legacy/PaymentService_PaymentRepository.html","filePath":"src/main/java/com/example/legacy/PaymentService.java","id":"com.example.legacy.PaymentService.PaymentRepository","loc":9,"methodCount":4,"packageName":"com.example.legacy","simpleName":"PaymentRepository"},{"complexityAvg":1.0,"complexityMax":1,"complexitySum":6,"detailLink":"src/main/java/com/example/legacy/PaymentService_GatewayResponse.html","filePath":"src/main/java/com/example/legacy/PaymentService.java","id":"com.example.legacy.PaymentService.GatewayResponse","loc":31,"methodCount":6,"packageName":"com.example.legacy","simpleName":"GatewayResponse"},{"complexityAvg":1.0,"complexityMax":1,"complexitySum":9,"detailLink":"src/main/java/com/example/legacy/PaymentService_Payment.html","filePath":"src/main/java/com/example/legacy/PaymentService.java","id":"com.example.legacy.PaymentService.Payment","loc":52,"methodCount":9,"packageName":"com.example.legacy","simpleName":"Payment"},{"complexityAvg":1.0,"complexityMax":1,"complexitySum":3,"detailLink":"src/main/java/com/example/legacy/PaymentService_PaymentResult.html","filePath":"src/main/java/com/example/legacy/PaymentService.java","id":"com.example.legacy.PaymentService.PaymentResult","loc":21,"methodCount":3,"packageName":"com.example.legacy","simpleName":"PaymentResult"},{"complexityAvg":1.0,"complexityMax":1,"complexitySum":3,"detailLink":"src/main/java/com/example/legacy/PaymentService_RefundResult.html","filePath":"src/main/java/com/example/legacy/PaymentService.java","id":"com.example.legacy.PaymentService.RefundResult","loc":22,"methodCount":3,"packageName":"com.example.legacy","simpleName":"RefundResult"},{"complexityAvg":1.1333333333333333,"complexityMax":3,"complexitySum":17,"detailLink":"src/main/java/com/example/legacy/SimpleCustomerData.html","filePath":"src/main/java/com/example/legacy/SimpleCustomerData.java","id":"com.example.legacy.SimpleCustomerData","loc":73,"methodCount":15,"packageName":"com.example.legacy","simpleName":"SimpleCustomerData"},{"complexityAvg":1.0,"complexityMax":1,"complexitySum":1,"detailLink":"src/main/java/com/example/legacy/service/NotificationService.html","filePath":"src/main/java/com/example/legacy/service/NotificationService.java","id":"com.example.legacy.service.NotificationService","loc":3,"methodCount":1,"packageName":"com.example.legacy.service","simpleName":"NotificationService"},{"complexityAvg":1.0,"complexityMax":1,"complexitySum":8,"detailLink":"src/main/java/com/example/legacy/service/Order.html","filePath":"src/main/java/com/example/legacy/service/Order.java","id":"com.example.legacy.service.Order","loc":28,"methodCount":8,"packageName":"com.example.legacy.service","simpleName":"Order"},{"complexityAvg":1.0,"complexityMax":1,"complexitySum":2,"detailLink":"src/main/java/com/example/legacy/service/OrderRepository.html","filePath":"src/main/java/com/example/legacy/service/OrderRepository.java","id":"com.example.legacy.service.OrderRepository","loc":5,"methodCount":2,"packageName":"com.example.legacy.service","simpleName":"OrderRepository"},{"complexityAvg":2.0,"complexityMax":3,"complexitySum":8,"detailLink":"src/main/java/com/example/legacy/service/OrderService.html","filePath":"src/main/java/com/example/legacy/service/OrderService.java","id":"com.example.legacy.service.OrderService","loc":59,"methodCount":4,"packageName":"com.example.legacy.service","simpleName":"OrderService"},{"complexityAvg":1.75,"complexityMax":3,"complexitySum":7,"detailLink":"src/main/java/com/example/legacy/util/StringUtil.html","filePath":"src/main/java/com/example/legacy/util/StringUtil.java","id":"com.example.legacy.util.StringUtil","loc":23,"methodCount":4,"packageName":"com.example.legacy.util","simpleName":"StringUtil"}],"complexityThreshold":20,"externalEdges":[{"from":"com.example.legacy","to":"com.google","weight":4}],"externalLibraries":[{"callCount":4,"id":"com.google"}],"fileEdges":[{"from":"src/main/java/com/example/legacy/MessageService.java","to":"src/main/java/com/example/legacy/util/StringUtil.java","weight":3},{"from":"src/main/java/com/example/legacy/service/OrderService.java","to":"src/main/java/com/example/legacy/service/OrderRepository.java","weight":4},{"from":"src/main/java/com/example/legacy/service/OrderService.java","to":"src/main/java/com/example/legacy/service/Order.java","weight":2},{"from":"src/main/java/com/example/legacy/service/OrderService.java","to":"src/main/java/com/example/legacy/service/NotificationService.java","weight":2},{"from":"src/main/java/com/example/legacy/ComplexInvoiceService.java","to":"src/main/java/com/example/legacy/SimpleCustomerData.java","weight":2}],"fileExternalEdges":[{"from":"src/main/java/com/example/legacy/OrderProcessingService.java","to":"com.google","weight":4}],"files":[{"classCount":3,"complexityAvg":4.444444444444445,"complexityMax":32,"complexitySum":40,"id":"src/main/java/com/example/legacy/ComplexInvoiceService.java","lineCoverage":0.0,"loc":275,"methodCount":9,"name":"ComplexInvoiceService.java","packageName":"com.example.legacy","path":"src/main/java/com/example/legacy/ComplexInvoiceService.java"},{"classCount":2,"complexityAvg":1.6111111111111112,"complexityMax":5,"complexitySum":29,"id":"src/main/java/com/example/legacy/CustomerService.java","lineCoverage":0.0,"loc":203,"methodCount":18,"name":"CustomerService.java","packageName":"com.example.legacy","path":"src/main/java/com/example/legacy/CustomerService.java"},{"classCount":1,"complexityAvg":1.1111111111111112,"complexityMax":2,"complexitySum":10,"id":"src/main/java/com/example/legacy/DynamicTestPatterns.java","lineCoverage":0.0,"loc":81,"methodCount":9,"name":"DynamicTestPatterns.java","packageName":"com.example.legacy","path":"src/main/java/com/example/legacy/DynamicTestPatterns.java"},{"classCount":1,"complexityAvg":1.0,"complexityMax":1,"complexitySum":4,"id":"src/main/java/com/example/legacy/ICustomerRepository.java","lineCoverage":null,"loc":33,"methodCount":4,"name":"ICustomerRepository.java","packageName":"com.example.legacy","path":"src/main/java/com/example/legacy/ICustomerRepository.java"},{"classCount":1,"complexityAvg":2.0,"complexityMax":3,"complexitySum":4,"id":"src/main/java/com/example/legacy/MessageService.java","lineCoverage":0.0,"loc":13,"methodCount":2,"name":"MessageService.java","packageName":"com.example.legacy","path":"src/main/java/com/example/legacy/MessageService.java"},{"classCount":1,"complexityAvg":1.0,"complexityMax":1,"complexitySum":3,"id":"src/main/java/com/example/legacy/OrderProcessingService.java","lineCoverage":0.0,"loc":19,"methodCount":3,"name":"OrderProcessingService.java","packageName":"com.example.legacy","path":"src/main/java/com/example/legacy/OrderProcessingService.java"},{"classCount":8,"complexityAvg":1.3428571428571427,"complexityMax":7,"complexitySum":47,"id":"src/main/java/com/example/legacy/PaymentService.java","lineCoverage":10.416666666666666,"loc":445,"methodCount":35,"name":"PaymentService.java","packageName":"com.example.legacy","path":"src/main/java/com/example/legacy/PaymentService.java"},{"classCount":1,"complexityAvg":1.1333333333333333,"complexityMax":3,"complexitySum":17,"id":"src/main/java/com/example/legacy/SimpleCustomerData.java","lineCoverage":0.0,"loc":73,"methodCount":15,"name":"SimpleCustomerData.java","packageName":"com.example.legacy","path":"src/main/java/com/example/legacy/SimpleCustomerData.java"},{"classCount":1,"complexityAvg":1.0,"complexityMax":1,"complexitySum":1,"id":"src/main/java/com/example/legacy/service/NotificationService.java","lineCoverage":null,"loc":3,"methodCount":1,"name":"NotificationService.java","packageName":"com.example.legacy.service","path":"src/main/java/com/example/legacy/service/NotificationService.java"},{"classCount":1,"complexityAvg":1.0,"complexityMax":1,"complexitySum":8,"id":"src/main/java/com/example/legacy/service/Order.java","lineCoverage":0.0,"loc":28,"methodCount":8,"name":"Order.java","packageName":"com.example.legacy.service","path":"src/main/java/com/example/legacy/service/Order.java"},{"classCount":1,"complexityAvg":1.0,"complexityMax":1,"complexitySum":2,"id":"src/main/java/com/example/legacy/service/OrderRepository.java","lineCoverage":null,"loc":5,"methodCount":2,"name":"OrderRepository.java","packageName":"com.example.legacy.service","path":"src/main/java/com/example/legacy/service/OrderRepository.java"},{"classCount":1,"complexityAvg":2.0,"complexityMax":3,"complexitySum":8,"id":"src/main/java/com/example/legacy/service/OrderService.java","lineCoverage":0.0,"loc":59,"methodCount":4,"name":"OrderService.java","packageName":"com.example.legacy.service","path":"src/main/java/com/example/legacy/service/OrderService.java"},{"classCount":1,"complexityAvg":1.75,"complexityMax":3,"complexitySum":7,"id":"src/main/java/com/example/legacy/util/StringUtil.java","lineCoverage":0.0,"loc":23,"methodCount":4,"name":"StringUtil.java","packageName":"com.example.legacy.util","path":"src/main/java/com/example/legacy/util/StringUtil.java"}],"generatedAt":"2026-02-13T03:35:08.761653734Z","packageEdges":[{"from":"com.example.legacy","to":"com.example.legacy.util","weight":3}],"packages":[{"classCount":18,"complexityAvg":1.6210526315789473,"complexityMax":32,"complexitySum":154,"id":"com.example.legacy","lineCoverage":3.6421911421911424,"loc":1142,"methodCount":95,"shortName":"legacy"},{"classCount":4,"complexityAvg":1.2666666666666666,"complexityMax":3,"complexitySum":19,"id":"com.example.legacy.service","lineCoverage":0.0,"loc":95,"methodCount":15,"shortName":"service"},{"classCount":1,"complexityAvg":1.75,"complexityMax":3,"complexitySum":7,"id":"com.example.legacy.util","lineCoverage":0.0,"loc":23,"methodCount":4,"shortName":"util"}],"projectId":"my-project","runId":"20260213_123502_A4D0","summary":{"complexityAvg":1.5789473684210527,"complexityMax":32,"complexitySum":180,"totalClasses":23,"totalLoc":1260,"totalMethods":114}}
    </script>

    <script type="application/json" id="analysis-report-markdown">
"# UT Generation Report\n\n- **Project**: my-project\n- **Run ID**: `20260213_123502_A4D0`\n- **Generated**: 2026-02-13 12:35:08\n\n## Summary\n\n| Metric | Value |\n|--------|-------|\n| Classes | 23 |\n| Methods | 114 |\n| Selected | 0 |\n| Excluded | 0 |\n\n## Analysis Hotspots\n\n| Metric | Value |\n|--------|-------|\n| High Complexity Methods (>= 15) | 1 |\n| Dead Code Candidates | 0 |\n| Duplicate Code Candidates | 20 |\n| Methods in Cycles | 0 |\n\n## Analyzed Classes\n\n| Class | Methods | LOC | Max Complexity | Avg Complexity |\n|-------|---------|-----|----------------|----------------|\n| [`com.example.legacy.ComplexInvoiceService`](src/main/java/com/example/legacy/ComplexInvoiceService.html) | 2 | 225 | 32 | 16.5 |\n| [`com.example.legacy.PaymentService`](src/main/java/com/example/legacy/PaymentService.html) | 6 | 300 | 7 | 3.0 |\n| [`com.example.legacy.CustomerService`](src/main/java/com/example/legacy/CustomerService.html) | 7 | 147 | 5 | 2.6 |\n| [`com.example.legacy.service.OrderService`](src/main/java/com/example/legacy/service/OrderService.html) | 4 | 59 | 3 | 2.0 |\n| [`com.example.legacy.MessageService`](src/main/java/com/example/legacy/MessageService.html) | 2 | 13 | 3 | 2.0 |\n| [`com.example.legacy.util.StringUtil`](src/main/java/com/example/legacy/util/StringUtil.html) | 4 | 23 | 3 | 1.8 |\n| [`com.example.legacy.SimpleCustomerData`](src/main/java/com/example/legacy/SimpleCustomerData.html) | 15 | 73 | 3 | 1.1 |\n| [`com.example.legacy.DynamicTestPatterns`](src/main/java/com/example/legacy/DynamicTestPatterns.html) | 9 | 81 | 2 | 1.1 |\n\n## Risky Methods\n\n| Class | Method | Complexity | LOC |\n|-------|--------|------------|-----|\n| `com.example.legacy.ComplexInvoiceService` | `calculateInvoice` | 32 | 166 |\n| `com.example.legacy.PaymentService` | `processPayment` | 7 | 45 |\n| `com.example.legacy.PaymentService` | `refundPayment` | 6 | 30 |\n| `com.example.legacy.CustomerService` | `getActiveCustomers` | 5 | 15 |\n| `com.example.legacy.CustomerService` | `findCustomerById` | 4 | 13 |\n| `com.example.legacy.service.OrderService` | `processOrder` | 3 | 19 |\n| `com.example.legacy.service.OrderService` | `cancelOrder` | 3 | 16 |\n| `com.example.legacy.SimpleCustomerData` | `equals` | 3 | 11 |\n| `com.example.legacy.MessageService` | `formatMessage` | 3 | 10 |\n| `com.example.legacy.CustomerService` | `addCustomer` | 3 | 9 |\n| `com.example.legacy.CustomerService` | `addCustomer` | 3 | 9 |\n| `com.example.legacy.util.StringUtil` | `truncate` | 3 | 9 |\n\n## Recommendations\n\n- Prioritize focused tests for `com.example.legacy.ComplexInvoiceService#calculateInvoice` (complexity=32).\n- Review `com.example.legacy.ComplexInvoiceService` for decomposition (methods=2, max complexity=32).\n- Maintain regression tests around payment, billing, and customer-facing business rules.\n\n"
    </script>

    <script>
      const data = JSON.parse(document.getElementById("analysis-data").textContent);
      const reportMarkdown = JSON.parse(
        document.getElementById("analysis-report-markdown").textContent
      );
      const uiConfig = {
        themes: {
          light: {
            "--bg-1": "#f4f1e8",
            "--bg-2": "#e4f2ec",
            "--ink": "#1f2a37",
            "--muted": "#667085",
            "--panel": "rgba(255, 255, 255, 0.84)",
            "--line": "rgba(31, 42, 55, 0.15)",
            "--high": "#e76f51",
            "--mid": "#e9c46a",
            "--low": "#2a9d8f",
            "--external": "#94a3b8",
            "--accent": "#1f6f5c",
            "--shadow": "0 24px 48px rgba(15, 23, 42, 0.14)",
            "--glow": "0 0 18px rgba(231, 111, 81, 0.35)",
          },
          dark: {
            "--bg-1": "#0f172a",
            "--bg-2": "#111827",
            "--ink": "#e2e8f0",
            "--muted": "#cbd5e1",
            "--panel": "rgba(15, 23, 42, 0.9)",
            "--line": "rgba(226, 232, 240, 0.18)",
            "--high": "#f97316",
            "--mid": "#facc15",
            "--low": "#34d399",
            "--external": "#94a3b8",
            "--accent": "#38bdf8",
            "--shadow": "0 24px 48px rgba(2, 6, 23, 0.5)",
            "--glow": "0 0 18px rgba(249, 115, 22, 0.45)",
          },
        },
        view: {
          externalNodeLimitBase: 6,
          externalNodeLimitMax: 12,
          detailConnectionLimit: 6,
          detailExternalLimit: 2,
          zoom: { min: 0.7, max: 2.8, step: 1.15 },
        },
        locales: {
          en: {
            lang: "en",
            types: { Package: "Package", File: "File" },
            navTitle: "Source Tree",
            navSubtitle: "Packages & Files",
            navFooter: "Select a source to focus the map.",
            dashOverallRisk: "Overall System Risk",
            dashHotspotDistribution: "Hotspot Distribution",
            dashPrimaryDriver: "Primary Leverage Driver",
            searchHint: "Search: Cmd + K / Ctrl + K",
            tabsAriaLabel: "Analysis views",
            tabVisual: "Leverage Map",
            tabReport: "Detailed Report",
            reportKicker: "Analysis Report",
            reportTitle: "Detailed Summary",
            reportSubtitle:
              "Read this narrative first, then check branch guards, representative paths, and called methods.",
            reportRawLink: "Open Raw Markdown",
            reportLoading: "Rendering report...",
            reportEmpty: "This run has no report.md output.",
            reportRenderError: "Failed to render report markdown.",
            reportCodeLabel: "Code",
            legend: { Low: "Low", Medium: "Medium", High: "High", External: "External" },
            mapHint:
              "Double-click a node to zoom in. Drag to pan. Scroll or use + / - to zoom.",
            detailSelected: "Selected Node",
            detailLeverageScore: "Leverage Score",
            detailMetrics: "Metrics",
            detailDocs: "Class Detail Reports",
            detailReasons: "Reasons",
            detailConnections: "Connected Nodes",
            paletteTitle: "Search packages or files",
            paletteHint: "Esc to close",
            palettePlaceholder: "Type a package or file name",
            resetLabel: "Reset",
            resetTitle: "Reset view",
            settingsTitle: "Settings",
            themeLabel: "Theme",
            localeLabel: "Locale",
            themeOptions: { light: "Light", dark: "Dark" },
            localeOptions: { en: "English", ja: "日本語" },
            defaultPackage: "(default)",
            systemRoot: "System",
            reasons: {
              highImpact: "High Impact",
              highComplexity: "High Complexity",
              lowCoverage: "Low Test Coverage",
            },
            riskLevels: { High: "High", Medium: "Medium", Low: "Low" },
            drivers: {
              Impact: "Impact-driven",
              Complexity: "Complexity-driven",
              TestGap: "TestGap-driven",
            },
            emptyConnections: "No nearby connections",
            noDetailDocs: "No class detail reports",
            emptyNodes: "No nodes available",
            externalDependency: "External dependency",
            externalPrefix: "External",
            noMatches: "No matches",
          },
          ja: {
            lang: "ja",
            types: { Package: "パッケージ", File: "ファイル" },
            navTitle: "ソースツリー",
            navSubtitle: "パッケージ & ファイル",
            navFooter: "ソースを選択してマップを絞り込みます。",
            dashOverallRisk: "システム全体リスク",
            dashHotspotDistribution: "ホットスポット分布",
            dashPrimaryDriver: "主要ドライバー",
            searchHint: "検索: Cmd + K / Ctrl + K",
            tabsAriaLabel: "分析ビュー",
            tabVisual: "レバレッジマップ",
            tabReport: "詳細レポート",
            reportKicker: "分析レポート",
            reportTitle: "詳細サマリー",
            reportSubtitle:
              "まず文章サマリーを確認し、その後に分岐ガード・代表パス・呼び出しメソッドを確認してください。",
            reportRawLink: "元のMarkdownを開く",
            reportLoading: "レポートを描画しています...",
            reportEmpty: "この実行には report.md がありません。",
            reportRenderError: "レポートMarkdownの描画に失敗しました。",
            reportCodeLabel: "コード",
            legend: { Low: "低", Medium: "中", High: "高", External: "外部" },
            mapHint:
              "ノードをダブルクリックで拡大。ドラッグで移動。スクロールまたは + / - でズーム。",
            detailSelected: "選択中ノード",
            detailLeverageScore: "レバレッジスコア",
            detailMetrics: "指標",
            detailDocs: "クラス詳細レポート",
            detailReasons: "理由",
            detailConnections: "接続ノード",
            paletteTitle: "パッケージまたはファイルを検索",
            paletteHint: "Escで閉じる",
            palettePlaceholder: "パッケージ/ファイル名を入力",
            resetLabel: "リセット",
            resetTitle: "表示をリセット",
            settingsTitle: "設定",
            themeLabel: "テーマ",
            localeLabel: "ロケール",
            themeOptions: { light: "ライト", dark: "ダーク" },
            localeOptions: { en: "English", ja: "日本語" },
            defaultPackage: "(デフォルト)",
            systemRoot: "システム",
            reasons: {
              highImpact: "影響が大きい",
              highComplexity: "複雑度が高い",
              lowCoverage: "テストカバレッジが低い",
            },
            riskLevels: { High: "高", Medium: "中", Low: "低" },
            drivers: {
              Impact: "影響主導",
              Complexity: "複雑度主導",
              TestGap: "テスト不足主導",
            },
            emptyConnections: "近隣の接続はありません",
            noDetailDocs: "クラス詳細レポートはありません",
            emptyNodes: "表示できるノードがありません",
            externalDependency: "外部依存",
            externalPrefix: "外部",
            noMatches: "一致する項目がありません",
          },
        },
        currentTheme: "light",
        currentLocale: "en",
      };
      const settingsStorage = {
        themeKey: "ful.analysis_visual.theme",
        localeKey: "ful.analysis_visual.locale",
      };
      const readSetting = (key) => {
        try {
          return window.localStorage ? localStorage.getItem(key) : null;
        } catch (error) {
          return null;
        }
      };
      const writeSetting = (key, value) => {
        try {
          if (window.localStorage && value) {
            localStorage.setItem(key, value);
          }
        } catch (error) {
          // Ignore storage errors (private mode or disabled storage).
        }
      };
      const storedTheme = readSetting(settingsStorage.themeKey);
      const storedLocale = readSetting(settingsStorage.localeKey);
      if (storedTheme && uiConfig.themes[storedTheme]) {
        uiConfig.currentTheme = storedTheme;
      }
      if (storedLocale && uiConfig.locales[storedLocale]) {
        uiConfig.currentLocale = storedLocale;
      }
      const mapSvg = document.getElementById("map");
      const tooltip = document.getElementById("tooltip");
      const breadcrumbs = document.getElementById("breadcrumbs");
      const overallRisk = document.getElementById("overall-risk");
      const hotspotDistribution = document.getElementById("hotspot-distribution");
      const primaryDriver = document.getElementById("primary-driver");
      const detailTitle = document.getElementById("detail-title");
      const detailScore = document.getElementById("detail-score");
      const detailMetrics = document.getElementById("detail-metrics");
      const detailDocs = document.getElementById("detail-docs");
      const detailReasons = document.getElementById("detail-reasons");
      const detailConnections = document.getElementById("detail-connections");
      const palette = document.getElementById("palette");
      const paletteInput = document.getElementById("palette-input");
      const paletteResults = document.getElementById("palette-results");
      const paletteBackdrop = document.getElementById("palette-backdrop");
      const sourceTree = document.getElementById("source-tree");
      const workspaceTabs = document.getElementById("workspace-tabs");
      const tabVisualButton = document.getElementById("tab-visual");
      const tabReportButton = document.getElementById("tab-report");
      const panelVisual = document.getElementById("panel-visual");
      const panelReport = document.getElementById("panel-report");
      const reportStatus = document.getElementById("report-status");
      const reportContent = document.getElementById("report-content");
      const reportRawLink = document.getElementById("report-raw-link");
      const treeIndex = new Map();
      const treeNodes = new Map();
      const treeState = new Map();

      const state = {
        level: 0,
        selectedPackageId: null,
        selectedFileId: null,
        activeTab: "visual",
      };

      const classes = data.classes || [];
      const allClassIds = new Set(classes.map((cls) => cls.id));
      const packages = (data.packages || []).filter(
        (pkg) =>
          pkg &&
          pkg.id !== null &&
          pkg.id !== undefined &&
          !allClassIds.has(pkg.id)
      );
      const packageById = new Map(packages.map((pkg) => [pkg.id, pkg]));
      const packageEdges = data.packageEdges || [];

      const files = data.files || [];
      const fileById = new Map(files.map((file) => [file.id, file]));
      const fileEdges = data.fileEdges || [];

      const externalEdges = data.externalEdges || [];
      const fileExternalEdges = data.fileExternalEdges || [];
      const { externalNodeLimitBase, externalNodeLimitMax, detailConnectionLimit, detailExternalLimit } =
        uiConfig.view;

      const zoomState = { scale: 1, translateX: 0, translateY: 0 };
      const zoomConfig = uiConfig.view.zoom;
      let mapLayer = null;
      let isDragging = false;
      let dragStart = null;

      let activeLabels = uiConfig.locales[uiConfig.currentLocale] || uiConfig.locales.en;

      function applyTheme(theme) {
        if (!theme) {
          return;
        }
        Object.entries(theme).forEach(([key, value]) => {
          document.documentElement.style.setProperty(key, value);
        });
      }

      function applyLabels(labels) {
        if (!labels) {
          return;
        }
        if (labels.lang) {
          document.documentElement.lang = labels.lang;
        }
        const setText = (id, value) => {
          const node = document.getElementById(id);
          if (node && value) {
            node.textContent = value;
          }
        };
        setText("nav-title", labels.navTitle);
        setText("nav-subtitle", labels.navSubtitle);
        setText("nav-footer-text", labels.navFooter);
        setText("settings-title", labels.settingsTitle);
        setText("settings-theme-label", labels.themeLabel);
        setText("settings-locale-label", labels.localeLabel);
        setText("dash-overall-risk-label", labels.dashOverallRisk);
        setText("dash-hotspot-label", labels.dashHotspotDistribution);
        setText("dash-primary-label", labels.dashPrimaryDriver);
        setText("search-hint", labels.searchHint);
        setText("legend-low", labels.legend?.Low);
        setText("legend-medium", labels.legend?.Medium);
        setText("legend-high", labels.legend?.High);
        setText("legend-external", labels.legend?.External);
        setText("map-hint", labels.mapHint);
        setText("detail-selected-label", labels.detailSelected);
        setText("detail-score-label", labels.detailLeverageScore);
        setText("detail-metrics-label", labels.detailMetrics);
        setText("detail-docs-label", labels.detailDocs);
        setText("detail-reasons-label", labels.detailReasons);
        setText("detail-connections-label", labels.detailConnections);
        setText("palette-title", labels.paletteTitle);
        setText("palette-hint", labels.paletteHint);
        setText("theme-option-light", labels.themeOptions?.light);
        setText("theme-option-dark", labels.themeOptions?.dark);
        setText("locale-option-en", labels.localeOptions?.en);
        setText("locale-option-ja", labels.localeOptions?.ja);
        setText("tab-visual", labels.tabVisual);
        setText("tab-report", labels.tabReport);
        setText("report-kicker", labels.reportKicker);
        setText("report-title", labels.reportTitle);
        setText("report-subtitle", labels.reportSubtitle);
        if (workspaceTabs && labels.tabsAriaLabel) {
          workspaceTabs.setAttribute("aria-label", labels.tabsAriaLabel);
        }
        if (reportRawLink && labels.reportRawLink) {
          reportRawLink.textContent = labels.reportRawLink;
        }
        const paletteInputField = document.getElementById("palette-input");
        if (paletteInputField && labels.palettePlaceholder) {
          paletteInputField.placeholder = labels.palettePlaceholder;
        }
        const resetButton = document.getElementById("reset-button");
        if (resetButton && labels.resetLabel) {
          resetButton.textContent = labels.resetLabel;
        }
        if (resetButton && labels.resetTitle) {
          resetButton.setAttribute("aria-label", labels.resetTitle);
          resetButton.setAttribute("title", labels.resetTitle);
        }
      }

      function applyLocale(locale) {
        if (!uiConfig.locales[locale]) {
          return;
        }
        uiConfig.currentLocale = locale;
        activeLabels = uiConfig.locales[locale];
        applyLabels(activeLabels);
        writeSetting(settingsStorage.localeKey, locale);
        if (state.activeTab === "report") {
          renderReportMarkdown(true);
          return;
        }
        renderAll();
      }

      function applyThemeSelection(themeName) {
        const theme = uiConfig.themes[themeName];
        if (!theme) {
          return;
        }
        uiConfig.currentTheme = themeName;
        applyTheme(theme);
        document.documentElement.setAttribute("data-theme", themeName);
        writeSetting(settingsStorage.themeKey, themeName);
      }

      function bindSettingsControls() {
        const themeSelect = document.getElementById("theme-select");
        const localeSelect = document.getElementById("locale-select");
        if (themeSelect) {
          themeSelect.value = uiConfig.currentTheme;
          themeSelect.addEventListener("change", (event) => {
            applyThemeSelection(event.target.value);
          });
        }
        if (localeSelect) {
          localeSelect.value = uiConfig.currentLocale;
          localeSelect.addEventListener("change", (event) => {
            applyLocale(event.target.value);
          });
        }
      }

      function escapeHtmlText(value) {
        if (value === null || value === undefined) {
          return "";
        }
        return String(value)
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;");
      }

      function escapeHtmlAttribute(value) {
        return escapeHtmlText(value).replace(/'/g, "&#39;");
      }

      function sanitizeHref(href) {
        if (!href) {
          return "#";
        }
        const trimmed = href.trim();
        const lower = trimmed.toLowerCase();
        if (lower.startsWith("javascript:") || lower.startsWith("data:")) {
          return "#";
        }
        return trimmed;
      }

      function renderInlineMarkdown(text) {
        let rendered = escapeHtmlText(text);
        rendered = rendered.replace(/`([^`]+)`/g, "<code>$1</code>");
        rendered = rendered.replace(
          /\[([^\]]+)\]\(([^)]+)\)/g,
          (match, label, href) =>
            `<a href="${escapeHtmlAttribute(
              sanitizeHref(href)
            )}" target="_blank" rel="noopener noreferrer">${label}</a>`
        );
        rendered = rendered.replace(/\*\*([^*]+)\*\*/g, "<strong>$1</strong>");
        rendered = rendered.replace(/__([^_]+)__/g, "<strong>$1</strong>");
        rendered = rendered.replace(/\*([^*]+)\*/g, "<em>$1</em>");
        rendered = rendered.replace(/_([^_]+)_/g, "<em>$1</em>");
        return rendered;
      }

      function splitTableCells(line) {
        const placeholder = "__FUL_PIPE__";
        const normalized = line
          .trim()
          .replace(/^\|/, "")
          .replace(/\|$/, "")
          .replace(/\\\|/g, placeholder);
        return normalized
          .split("|")
          .map((cell) => cell.replace(new RegExp(placeholder, "g"), "|").trim());
      }

      function isTableSeparatorLine(line) {
        return /^\s*\|?\s*:?-{3,}:?\s*(\|\s*:?-{3,}:?\s*)+\|?\s*$/.test(line || "");
      }

      function isTableBlockStart(lines, index) {
        if (!lines[index] || !lines[index + 1]) {
          return false;
        }
        if (!lines[index].includes("|")) {
          return false;
        }
        return isTableSeparatorLine(lines[index + 1]);
      }

      function renderMarkdownToHtml(markdownText) {
        const source = (markdownText || "").replace(/\r\n?/g, "\n");
        if (!source.trim()) {
          return "";
        }
        const lines = source.split("\n");
        let index = 0;
        const chunks = [];
        let paragraphLines = [];

        function flushParagraph() {
          if (!paragraphLines.length) {
            return;
          }
          const paragraph = paragraphLines.join(" ").trim();
          if (paragraph) {
            chunks.push(`<p>${renderInlineMarkdown(paragraph)}</p>`);
          }
          paragraphLines = [];
        }

        function collectCodeBlock() {
          const opener = lines[index].trim();
          const language = opener.length > 3 ? opener.substring(3).trim() : "";
          index += 1;
          const body = [];
          while (index < lines.length && !lines[index].trim().startsWith("```")) {
            body.push(lines[index]);
            index += 1;
          }
          if (index < lines.length && lines[index].trim().startsWith("```")) {
            index += 1;
          }
          const title = language
            ? `${activeLabels.reportCodeLabel}: ${escapeHtmlText(language)}`
            : activeLabels.reportCodeLabel;
          return (
            `<figure class="report-code-block"><span class="report-code-title">${title}</span>` +
            `<pre><code>${escapeHtmlText(body.join("\n"))}</code></pre></figure>`
          );
        }

        function collectList(ordered) {
          const pattern = ordered ? /^\s*\d+\.\s+(.+)$/ : /^\s*[-*]\s+(.+)$/;
          const tag = ordered ? "ol" : "ul";
          const items = [];
          while (index < lines.length) {
            const match = lines[index].match(pattern);
            if (!match) {
              break;
            }
            items.push(`<li>${renderInlineMarkdown(match[1].trim())}</li>`);
            index += 1;
          }
          return `<${tag}>${items.join("")}</${tag}>`;
        }

        function collectBlockquote() {
          const quoteLines = [];
          while (index < lines.length) {
            const match = lines[index].match(/^\s*>\s?(.*)$/);
            if (!match) {
              break;
            }
            quoteLines.push(match[1]);
            index += 1;
          }
          const quote = quoteLines.join(" ").trim();
          return `<blockquote>${renderInlineMarkdown(quote)}</blockquote>`;
        }

        function collectTable() {
          const headers = splitTableCells(lines[index]);
          index += 2;
          const rows = [];
          while (index < lines.length) {
            const line = lines[index];
            if (!line || !line.trim() || !line.includes("|")) {
              break;
            }
            rows.push(splitTableCells(line));
            index += 1;
          }
          const headerHtml = headers
            .map((header) => `<th>${renderInlineMarkdown(header)}</th>`)
            .join("");
          const bodyHtml = rows
            .map((row) => {
              const cells = headers.map((header, cellIndex) => row[cellIndex] || "");
              return `<tr>${cells
                .map((cell) => `<td>${renderInlineMarkdown(cell)}</td>`)
                .join("")}</tr>`;
            })
            .join("");
          return `<table><thead><tr>${headerHtml}</tr></thead><tbody>${bodyHtml}</tbody></table>`;
        }

        while (index < lines.length) {
          const line = lines[index];
          const trimmed = line.trim();

          if (!trimmed) {
            flushParagraph();
            index += 1;
            continue;
          }

          if (trimmed.startsWith("```")) {
            flushParagraph();
            chunks.push(collectCodeBlock());
            continue;
          }

          if (isTableBlockStart(lines, index)) {
            flushParagraph();
            chunks.push(collectTable());
            continue;
          }

          const heading = line.match(/^(#{1,6})\s+(.*)$/);
          if (heading) {
            flushParagraph();
            const level = heading[1].length;
            chunks.push(`<h${level}>${renderInlineMarkdown(heading[2].trim())}</h${level}>`);
            index += 1;
            continue;
          }

          if (/^\s*[-*]\s+/.test(line)) {
            flushParagraph();
            chunks.push(collectList(false));
            continue;
          }

          if (/^\s*\d+\.\s+/.test(line)) {
            flushParagraph();
            chunks.push(collectList(true));
            continue;
          }

          if (/^\s*>\s?/.test(line)) {
            flushParagraph();
            chunks.push(collectBlockquote());
            continue;
          }

          if (/^\s*([-*_])\1{2,}\s*$/.test(line)) {
            flushParagraph();
            chunks.push("<hr />");
            index += 1;
            continue;
          }

          paragraphLines.push(trimmed);
          index += 1;
        }

        flushParagraph();
        return chunks.join("");
      }

      function renderReportMarkdown(forceRender) {
        if (!reportContent || !reportStatus) {
          return;
        }
        const markdownText = typeof reportMarkdown === "string" ? reportMarkdown : "";
        if (!markdownText.trim()) {
          reportContent.innerHTML = "";
          reportContent.hidden = true;
          reportStatus.hidden = false;
          reportStatus.textContent = activeLabels.reportEmpty;
          return;
        }
        if (forceRender) {
          reportContent.dataset.locale = "";
        }
        if (reportContent.dataset.locale === uiConfig.currentLocale && reportContent.innerHTML) {
          reportContent.hidden = false;
          reportStatus.hidden = true;
          return;
        }
        reportStatus.hidden = false;
        reportStatus.textContent = activeLabels.reportLoading;
        try {
          reportContent.innerHTML = renderMarkdownToHtml(markdownText);
          reportContent.dataset.locale = uiConfig.currentLocale;
          reportContent.hidden = false;
          reportStatus.hidden = true;
        } catch (error) {
          reportContent.innerHTML = "";
          reportContent.hidden = true;
          reportStatus.hidden = false;
          reportStatus.textContent = activeLabels.reportRenderError;
        }
      }

      function setActiveTab(tabId, focusTab) {
        if (tabId !== "visual" && tabId !== "report") {
          return;
        }
        state.activeTab = tabId;
        const showVisual = tabId === "visual";

        if (tabVisualButton) {
          tabVisualButton.classList.toggle("is-active", showVisual);
          tabVisualButton.setAttribute("aria-selected", showVisual ? "true" : "false");
          tabVisualButton.setAttribute("tabindex", showVisual ? "0" : "-1");
        }
        if (tabReportButton) {
          tabReportButton.classList.toggle("is-active", !showVisual);
          tabReportButton.setAttribute("aria-selected", showVisual ? "false" : "true");
          tabReportButton.setAttribute("tabindex", showVisual ? "-1" : "0");
        }
        if (panelVisual) {
          panelVisual.classList.toggle("is-active", showVisual);
          panelVisual.hidden = !showVisual;
        }
        if (panelReport) {
          panelReport.classList.toggle("is-active", !showVisual);
          panelReport.hidden = showVisual;
        }

        if (showVisual) {
          requestAnimationFrame(() => {
            renderAll();
          });
        } else {
          closePalette();
          hideTooltip();
          renderReportMarkdown(false);
        }

        if (focusTab) {
          const target = showVisual ? tabVisualButton : tabReportButton;
          if (target) {
            target.focus();
          }
        }
      }

      function bindWorkspaceTabs() {
        const tabs = [tabVisualButton, tabReportButton].filter(Boolean);
        tabs.forEach((tab) => {
          tab.addEventListener("click", () => {
            setActiveTab(tab.dataset.tab, false);
          });
        });
        if (!workspaceTabs || tabs.length < 2) {
          return;
        }
        workspaceTabs.addEventListener("keydown", (event) => {
          const key = event.key;
          const currentIndex = tabs.findIndex((tab) => tab.dataset.tab === state.activeTab);
          if (key === "ArrowRight" || key === "ArrowLeft") {
            event.preventDefault();
            const nextIndex =
              key === "ArrowRight"
                ? (currentIndex + 1) % tabs.length
                : (currentIndex - 1 + tabs.length) % tabs.length;
            setActiveTab(tabs[nextIndex].dataset.tab, true);
            return;
          }
          if (key === "Home" || key === "End") {
            event.preventDefault();
            const nextIndex = key === "Home" ? 0 : tabs.length - 1;
            setActiveTab(tabs[nextIndex].dataset.tab, true);
          }
        });
      }

      function normalize(value, min, max) {
        if (max === min) {
          return 0.5;
        }
        const ratio = (value - min) / (max - min);
        return Math.min(Math.max(ratio, 0), 1);
      }

      function sumEdgeWeights(edges) {
        const sums = new Map();
        edges.forEach((edge) => {
          const fromValue = sums.get(edge.from) || 0;
          const toValue = sums.get(edge.to) || 0;
          sums.set(edge.from, fromValue + edge.weight);
          sums.set(edge.to, toValue + edge.weight);
        });
        return sums;
      }

      function buildAdjacency(edges) {
        const adjacency = new Map();
        edges.forEach((edge) => {
          if (!adjacency.has(edge.from)) {
            adjacency.set(edge.from, new Map());
          }
          if (!adjacency.has(edge.to)) {
            adjacency.set(edge.to, new Map());
          }
          const fromMap = adjacency.get(edge.from);
          fromMap.set(edge.to, (fromMap.get(edge.to) || 0) + edge.weight);
          const toMap = adjacency.get(edge.to);
          toMap.set(edge.from, (toMap.get(edge.from) || 0) + edge.weight);
        });
        return adjacency;
      }

      function computeScores(nodes, edges, accessors) {
        const edgeWeights = sumEdgeWeights(edges);
        let minComplexityMax = Infinity;
        let maxComplexityMax = -Infinity;
        let minComplexitySum = Infinity;
        let maxComplexitySum = -Infinity;
        let minLoc = Infinity;
        let maxLoc = -Infinity;
        let minEdge = Infinity;
        let maxEdge = -Infinity;
        const coverageGapById = new Map();
        const coverageGaps = [];

        nodes.forEach((node) => {
          const complexityMax = accessors.complexityMax(node) || 0;
          const complexitySum = accessors.complexitySum(node) || 0;
          const loc = accessors.loc(node) || 0;
          const edgeWeight = edgeWeights.get(node.id) || 0;
          minComplexityMax = Math.min(minComplexityMax, complexityMax);
          maxComplexityMax = Math.max(maxComplexityMax, complexityMax);
          minComplexitySum = Math.min(minComplexitySum, complexitySum);
          maxComplexitySum = Math.max(maxComplexitySum, complexitySum);
          minLoc = Math.min(minLoc, loc);
          maxLoc = Math.max(maxLoc, loc);
          minEdge = Math.min(minEdge, edgeWeight);
          maxEdge = Math.max(maxEdge, edgeWeight);

          if (accessors.coverage) {
            const coverageValue = accessors.coverage(node);
            if (Number.isFinite(coverageValue) && coverageValue >= 0) {
              const clamped = Math.min(Math.max(coverageValue, 0), 100);
              const gap = 1 - clamped / 100;
              coverageGapById.set(node.id, gap);
              coverageGaps.push(gap);
            }
          }
        });

        const hasCoverage = coverageGaps.length > 0;
        const minCoverageGap = hasCoverage ? Math.min(...coverageGaps) : 0;
        const maxCoverageGap = hasCoverage ? Math.max(...coverageGaps) : 1;

        const scoreMap = new Map();
        const leverageValues = [];

        nodes.forEach((node) => {
          const complexityMax = accessors.complexityMax(node) || 0;
          const complexitySum = accessors.complexitySum(node) || 0;
          const loc = accessors.loc(node) || 0;
          const edgeWeight = edgeWeights.get(node.id) || 0;
          const coverageGap = coverageGapById.get(node.id);
          const hasNodeCoverage =
            coverageGap !== undefined && coverageGap !== null && Number.isFinite(coverageGap);

          const impactScore =
            0.45 * normalize(complexitySum, minComplexitySum, maxComplexitySum) +
            0.35 * normalize(edgeWeight, minEdge, maxEdge) +
            0.2 * normalize(loc, minLoc, maxLoc);
          const complexityScore = normalize(complexityMax, minComplexityMax, maxComplexityMax);
          const coverageScore =
            hasCoverage && hasNodeCoverage
              ? normalize(coverageGap, minCoverageGap, maxCoverageGap)
              : 0;
          const coverageWeight = hasNodeCoverage ? 0.2 : 0;
          const complexityWeight = hasNodeCoverage ? 0.3 : 0.4;
          const impactWeight = 1 - coverageWeight - complexityWeight;
          const leverageScore =
            impactWeight * impactScore +
            complexityWeight * complexityScore +
            coverageWeight * coverageScore;

          scoreMap.set(node.id, {
            impactScore,
            complexityScore,
            coverageScore,
            coverageGap: hasNodeCoverage ? coverageGap : null,
            hasCoverage: hasNodeCoverage,
            leverageScore,
            edgeWeight,
            level: "Medium",
          });
          leverageValues.push(leverageScore);
        });

        leverageValues.sort((a, b) => a - b);
        const mediumIndex = Math.floor(leverageValues.length * 0.34);
        const highIndex = Math.floor(leverageValues.length * 0.67);
        const mediumThreshold = leverageValues[mediumIndex] ?? 0.34;
        const highThreshold = leverageValues[highIndex] ?? 0.67;

        scoreMap.forEach((score) => {
          if (score.leverageScore >= highThreshold) {
            score.level = "High";
          } else if (score.leverageScore >= mediumThreshold) {
            score.level = "Medium";
          } else {
            score.level = "Low";
          }
        });

        return scoreMap;
      }

      const packageScores = computeScores(packages, packageEdges, {
        complexityMax: (node) => node.complexityMax,
        complexitySum: (node) => node.complexitySum,
        loc: (node) => node.loc,
        coverage: (node) => node.lineCoverage,
      });

      const fileScores = computeScores(files, fileEdges, {
        complexityMax: (node) => node.complexityMax,
        complexitySum: (node) => node.complexitySum,
        loc: (node) => node.loc,
        coverage: (node) => node.lineCoverage,
      });

      const packageAdjacency = buildAdjacency(packageEdges);
      const fileAdjacency = buildAdjacency(fileEdges);

      function getTopNode(nodes, scores) {
        if (!nodes.length) {
          return null;
        }
        return nodes
          .slice()
          .sort((a, b) => scores.get(b.id).leverageScore - scores.get(a.id).leverageScore)[0];
      }

      function buildSearchIndex() {
        const items = [];
        packages.forEach((pkg) => {
          const score = packageScores.get(pkg.id);
          const name = packageDisplayName(pkg);
          items.push({
            id: pkg.id,
            type: "Package",
            name,
            label: packageShortLabel(pkg),
            scoreLabel: score.level,
            scoreValue: score.leverageScore,
            searchKey: `${name} ${packageShortLabel(pkg)}`.toLowerCase(),
          });
        });
        files.forEach((file) => {
          const packageName = file.packageName || "";
          const score = fileScores.get(file.id);
          items.push({
            id: file.id,
            type: "File",
            name: file.name,
            label: file.name,
            packageName,
            scoreLabel: score.level,
            scoreValue: score.leverageScore,
            searchKey: `${file.name} ${packageName}`.toLowerCase(),
          });
        });
        return items;
      }

      const searchIndex = buildSearchIndex();

      function resolveTreeExpanded(id, depth, hasChildren) {
        if (treeState.has(id)) {
          return treeState.get(id);
        }
        if (!hasChildren) {
          treeState.set(id, false);
          return false;
        }
        const expanded = depth <= 1;
        treeState.set(id, expanded);
        return expanded;
      }

      function setTreeExpanded(id, expanded) {
        treeState.set(id, expanded);
        const node = treeNodes.get(id);
        if (!node) {
          return;
        }
        node.item.classList.toggle("is-collapsed", !expanded);
        node.toggle.textContent = expanded ? "v" : ">";
        node.toggle.setAttribute("aria-expanded", expanded ? "true" : "false");
      }

      function toggleTreeNode(id) {
        const current = treeState.get(id);
        setTreeExpanded(id, !current);
      }

      function expandTreePath(packageId) {
        if (packageId === null || packageId === undefined) {
          return;
        }
        if (packageId === "") {
          setTreeExpanded("", true);
          return;
        }
        const parts = packageId.split(".");
        let path = "";
        parts.forEach((part) => {
          path = path ? `${path}.${part}` : part;
          setTreeExpanded(path, true);
        });
      }

      function buildSourceTree() {
        treeIndex.clear();
        treeNodes.clear();
        if (!sourceTree) {
          return;
        }
        const root = { id: null, name: null, children: new Map(), files: [] };
        const packageNames = new Set();
        packages.forEach((pkg) => {
          packageNames.add(pkg.id ?? "");
        });
        files.forEach((file) => {
          packageNames.add(file.packageName || "");
        });

        function ensurePackageNode(fullName) {
          if (fullName === "") {
            if (!root.children.has("")) {
              root.children.set("", {
                id: "",
                name: "(default)",
                children: new Map(),
                files: [],
              });
            }
            return root.children.get("");
          }
          const parts = fullName.split(".");
          let current = root;
          let path = "";
          parts.forEach((part) => {
            path = path ? `${path}.${part}` : part;
            if (!current.children.has(part)) {
              current.children.set(part, {
                id: path,
                name: part,
                children: new Map(),
                files: [],
              });
            }
            current = current.children.get(part);
          });
          return current;
        }

        packageNames.forEach((name) => {
          if (name === "" || name) {
            ensurePackageNode(name);
          }
        });

        files.forEach((file) => {
          const pkgName = file.packageName || "";
          const node = ensurePackageNode(pkgName);
          node.files.push(file);
        });

        function sortPackages(list) {
          return list.sort((a, b) => {
            if (a.id === "") {
              return -1;
            }
            if (b.id === "") {
              return 1;
            }
            return a.name.localeCompare(b.name);
          });
        }

        function sortFiles(list) {
          return list.sort((a, b) => a.name.localeCompare(b.name));
        }

        function registerTreeButton(button, type, id) {
          treeIndex.set(`${type}:${id}`, button);
        }

        function renderPackageNode(node, depth) {
          const li = document.createElement("li");
          li.className = "tree-item";
          const row = document.createElement("div");
          row.className = "tree-row";
          const toggle = document.createElement("button");
          toggle.type = "button";
          toggle.className = "tree-toggle";
          toggle.dataset.action = "toggle";
          toggle.dataset.id = node.id;
          const button = document.createElement("button");
          button.type = "button";
          button.className = "tree-button tree-package";
          button.textContent = node.name;
          if (packageById.has(node.id)) {
            button.dataset.type = "package";
            button.dataset.id = node.id;
            registerTreeButton(button, "package", node.id);
          } else {
            button.classList.add("is-disabled");
            button.disabled = true;
          }

          const childPackages = sortPackages(Array.from(node.children.values()));
          const childFiles = sortFiles(node.files.slice());
          const hasChildren = childPackages.length > 0 || childFiles.length > 0;
          if (!hasChildren) {
            toggle.classList.add("is-hidden");
            toggle.disabled = true;
          }
          const expanded = resolveTreeExpanded(node.id, depth, hasChildren);
          if (!expanded) {
            li.classList.add("is-collapsed");
          }
          toggle.textContent = expanded ? "v" : ">";
          toggle.setAttribute("aria-label", "Toggle folder");
          toggle.setAttribute("aria-expanded", expanded ? "true" : "false");

          row.appendChild(toggle);
          row.appendChild(button);
          li.appendChild(row);
          treeNodes.set(node.id, { item: li, toggle });

          if (childPackages.length || childFiles.length) {
            const childList = document.createElement("ul");
            childList.className = "tree-group";
            childPackages.forEach((child) => {
              childList.appendChild(renderPackageNode(child, depth + 1));
            });
            childFiles.forEach((file) => {
              const fileItem = document.createElement("li");
              fileItem.className = "tree-item";
              const fileButton = document.createElement("button");
              fileButton.type = "button";
              fileButton.className = "tree-button tree-file";
              fileButton.textContent = file.name;
              fileButton.dataset.type = "file";
              fileButton.dataset.id = file.id;
              registerTreeButton(fileButton, "file", file.id);
              fileItem.appendChild(fileButton);
              childList.appendChild(fileItem);
            });
            li.appendChild(childList);
          }
          return li;
        }

        const rootList = document.createElement("ul");
        rootList.className = "tree-root";
        const topLevel = sortPackages(Array.from(root.children.values()));

        sourceTree.innerHTML = "";
        if (!topLevel.length) {
          const empty = document.createElement("div");
          empty.className = "tree-empty";
          empty.textContent = "No source data";
          sourceTree.appendChild(empty);
          return;
        }
        topLevel.forEach((node) => {
          rootList.appendChild(renderPackageNode(node, 0));
        });
        sourceTree.appendChild(rootList);
      }

      function updateTreeSelection() {
        if (!sourceTree || treeIndex.size === 0) {
          return;
        }
        treeIndex.forEach((button) => button.classList.remove("is-active"));
        if (state.level === 0 && state.selectedPackageId !== null && state.selectedPackageId !== undefined) {
          expandTreePath(state.selectedPackageId);
          const button = treeIndex.get(`package:${state.selectedPackageId}`);
          if (button) {
            button.classList.add("is-active");
          }
          return;
        }
        if (state.selectedFileId) {
          const file = fileById.get(state.selectedFileId);
          if (file) {
            expandTreePath(file.packageName || "");
          }
          const button = treeIndex.get(`file:${state.selectedFileId}`);
          if (button) {
            button.classList.add("is-active");
          }
        }
      }

      function bindSourceTree() {
        if (!sourceTree) {
          return;
        }
        sourceTree.addEventListener("click", (event) => {
          const toggle = event.target.closest(".tree-toggle");
          if (toggle && !toggle.disabled) {
            event.stopPropagation();
            toggleTreeNode(toggle.dataset.id);
            return;
          }
          const button = event.target.closest(".tree-button");
          if (!button || button.disabled) {
            return;
          }
          const type = button.dataset.type;
          const id = button.dataset.id;
          if (!type || id === undefined) {
            return;
          }
          if (type === "package") {
            state.level = 0;
            state.selectedPackageId = id;
            state.selectedFileId = null;
          } else {
            state.level = 2;
            state.selectedFileId = id;
            const file = fileById.get(id);
            state.selectedPackageId = file ? file.packageName : null;
          }
          renderAll();
          requestAnimationFrame(() => {
            animateSearchFocus();
          });
        });
      }

      function filterFilesForPackage(packageId) {
        if (packageId === null || packageId === undefined) {
          return files;
        }
        return files.filter((file) => {
          if (file.packageName === null || file.packageName === undefined) {
            return false;
          }
          if (file.packageName === packageId) {
            return true;
          }
          if (file.packageName && packageId) {
            return file.packageName.startsWith(`${packageId}.`);
          }
          return false;
        });
      }

      function buildFileContext(packageId) {
        const scopedFiles = filterFilesForPackage(packageId);
        const fileIds = new Set(scopedFiles.map((file) => file.id));
        const scopedEdges = fileEdges.filter(
          (edge) => fileIds.has(edge.from) && fileIds.has(edge.to)
        );
        const scopedAdjacency = buildAdjacency(scopedEdges);
        return { scopedFiles, scopedEdges, scopedAdjacency };
      }

      function resolveHopDistances(adjacency, focusId, maxHop) {
        const distances = new Map();
        if (!focusId || !adjacency.has(focusId)) {
          return distances;
        }
        const queue = [{ id: focusId, depth: 0 }];
        distances.set(focusId, 0);

        while (queue.length > 0) {
          const current = queue.shift();
          if (current.depth >= maxHop) {
            continue;
          }
          const neighbors = adjacency.get(current.id) || new Map();
          neighbors.forEach((value, neighborId) => {
            if (!distances.has(neighborId)) {
              distances.set(neighborId, current.depth + 1);
              queue.push({ id: neighborId, depth: current.depth + 1 });
            }
          });
        }
        return distances;
      }

      function toScoreClass(level) {
        return `score-${level.toLowerCase()}`;
      }

      function buildReasons(score) {
        const reasons = [];
        if (score.impactScore >= 0.5) {
          reasons.push(activeLabels.reasons.highImpact);
        }
        if (score.complexityScore >= 0.5) {
          reasons.push(activeLabels.reasons.highComplexity);
        }
        if (score.hasCoverage && score.coverageGap !== null && score.coverageGap >= 0.5) {
          reasons.push(activeLabels.reasons.lowCoverage);
        }
        if (reasons.length === 0) {
          if (score.impactScore >= score.complexityScore) {
            reasons.push(activeLabels.reasons.highImpact);
          } else {
            reasons.push(activeLabels.reasons.highComplexity);
          }
        }
        return reasons.slice(0, 3);
      }

      function buildExternalConnections(edges, fromId, limit) {
        if (fromId === null || fromId === undefined) {
          return [];
        }
        return edges
          .filter((edge) => edge.from === fromId)
          .sort((a, b) => b.weight - a.weight)
          .slice(0, limit)
          .map((edge) => ({
            label: `${activeLabels.externalPrefix}: ${edge.to}`,
            score: null,
            kind: "External",
          }));
      }

      function updateBreadcrumbs() {
        while (breadcrumbs.firstChild) {
          breadcrumbs.removeChild(breadcrumbs.firstChild);
        }
        const rootLabel =
          data.projectId && data.projectId !== "unknown"
            ? data.projectId
            : activeLabels.systemRoot;
        const parts = [{ label: rootLabel, level: 0 }];
        if (state.level >= 1 && state.selectedPackageId !== null && state.selectedPackageId !== undefined) {
          const packageLabel =
            state.selectedPackageId === ""
              ? activeLabels.defaultPackage
              : state.selectedPackageId;
          parts.push({ label: packageLabel, level: 1 });
        }
        if (state.level === 2 && state.selectedFileId) {
          const file = fileById.get(state.selectedFileId);
          parts.push({ label: file ? file.name : state.selectedFileId, level: 2 });
        }

        parts.forEach((part, index) => {
          const button = document.createElement("button");
          button.className = "crumb";
          if (index === parts.length - 1) {
            button.classList.add("is-active");
          }
          button.textContent = part.label;
          button.dataset.level = part.level;
          button.addEventListener("click", () => {
            if (index === parts.length - 1) {
              return;
            }
            if (part.level === 0) {
              state.level = 0;
              state.selectedFileId = null;
            }
            if (part.level === 1) {
              state.level = 1;
            }
            resetZoom();
            renderAll();
          });
          breadcrumbs.appendChild(button);
          if (index < parts.length - 1) {
            const sep = document.createElement("span");
            sep.className = "crumb-sep";
            sep.textContent = ">";
            breadcrumbs.appendChild(sep);
          }
        });
      }

      function updateDashboard(nodes, scores) {
        const distribution = { High: 0, Medium: 0, Low: 0 };
        nodes.forEach((node) => {
          const score = scores.get(node.id);
          if (score) {
            distribution[score.level] += 1;
          }
        });

        const total = nodes.length || 1;
        const highRatio = distribution.High / total;
        let risk = activeLabels.riskLevels.Low;
        if (highRatio >= 0.3) {
          risk = activeLabels.riskLevels.High;
        } else if (highRatio >= 0.15) {
          risk = activeLabels.riskLevels.Medium;
        }
        overallRisk.textContent = risk;

        hotspotDistribution.innerHTML = "";
        ["High", "Medium", "Low"].forEach((level) => {
          const chip = document.createElement("span");
          chip.className = "dash-chip";
          const label = activeLabels.riskLevels[level] || level;
          chip.textContent = `${label} ${distribution[level]}`;
          hotspotDistribution.appendChild(chip);
        });

        const topNodes = nodes
          .slice()
          .sort((a, b) => scores.get(b.id).leverageScore - scores.get(a.id).leverageScore)
          .slice(0, 8);
        const driverCounts = { Impact: 0, Complexity: 0, TestGap: 0 };
        let hasCoverage = false;
        topNodes.forEach((node) => {
          const score = scores.get(node.id);
          if (!score) {
            return;
          }
          const hasNodeCoverage = score.hasCoverage;
          if (hasNodeCoverage) {
            hasCoverage = true;
          }
          let driver = "Impact";
          let maxScore = score.impactScore;
          if (score.complexityScore > maxScore) {
            driver = "Complexity";
            maxScore = score.complexityScore;
          }
          if (hasNodeCoverage && score.coverageScore > maxScore) {
            driver = "TestGap";
          }
          driverCounts[driver] += 1;
        });
        let driver = "Impact";
        if (driverCounts.Complexity > driverCounts[driver]) {
          driver = "Complexity";
        }
        if (hasCoverage && driverCounts.TestGap > driverCounts[driver]) {
          driver = "TestGap";
        }
        primaryDriver.textContent =
          activeLabels.drivers[driver] || activeLabels.drivers.Impact;
      }

      function updateDetailPanel(selection) {
        if (!selection) {
          detailTitle.textContent = "-";
          detailScore.textContent = "-";
          detailScore.className = "detail-score";
          detailMetrics.innerHTML = "";
          detailDocs.innerHTML = "";
          detailReasons.innerHTML = "";
          detailConnections.innerHTML = "";
          return;
        }

        const displayType =
          activeLabels.types[selection.type] || selection.type || activeLabels.types.Package;
        detailTitle.textContent = `${displayType}: ${selection.name}`;
        detailScore.textContent = selection.score.level;
        detailScore.className = `detail-score ${toScoreClass(selection.score.level)}`;

        detailMetrics.innerHTML = "";
        const metrics = selection.metrics || [];
        metrics.forEach((metric) => {
          const li = document.createElement("li");
          const label = document.createElement("span");
          label.textContent = metric.label;
          const value = document.createElement("span");
          value.className = "detail-value";
          value.textContent = metric.value;
          if (metric.title) {
            value.title = metric.title;
          } else if (metric.value && metric.value.length > 12) {
            value.title = metric.value;
          }
          li.appendChild(label);
          li.appendChild(value);
          detailMetrics.appendChild(li);
        });

        detailDocs.innerHTML = "";
        const detailLinks = selection.detailLinks || [];
        if (!detailLinks.length) {
          const li = document.createElement("li");
          li.className = "detail-doc-item";
          li.textContent = activeLabels.noDetailDocs;
          detailDocs.appendChild(li);
        } else {
          detailLinks.forEach((detail) => {
            if (!detail || !detail.href) {
              return;
            }
            const li = document.createElement("li");
            li.className = "detail-doc-item";
            const link = document.createElement("a");
            link.className = "detail-link";
            link.href = detail.href;
            link.textContent = detail.label || detail.href;
            link.title = detail.href;
            li.appendChild(link);
            detailDocs.appendChild(li);
          });
        }

        detailReasons.innerHTML = "";
        selection.reasons.forEach((reason) => {
          const li = document.createElement("li");
          li.textContent = reason;
          detailReasons.appendChild(li);
        });

        detailConnections.innerHTML = "";
        if (!selection.connections.length) {
          const li = document.createElement("li");
          li.textContent = activeLabels.emptyConnections;
          detailConnections.appendChild(li);
          return;
        }
        selection.connections.forEach((connection) => {
          const li = document.createElement("li");
          const name = document.createElement("span");
          name.textContent = connection.label;
          const score = document.createElement("span");
          score.className = "detail-pill";
          score.textContent = connection.score
            ? connection.score.level
            : connection.kind || activeLabels.externalPrefix;
          li.appendChild(name);
          li.appendChild(score);
          detailConnections.appendChild(li);
        });
      }

      function createSvgElement(type, attrs) {
        const node = document.createElementNS("http://www.w3.org/2000/svg", type);
        Object.entries(attrs).forEach(([key, value]) => node.setAttribute(key, value));
        return node;
      }

      function applyTransform() {
        if (!mapLayer) {
          return;
        }
        mapLayer.setAttribute(
          "transform",
          `translate(${zoomState.translateX} ${zoomState.translateY}) scale(${zoomState.scale})`
        );
      }

      function resetZoom() {
        zoomState.scale = 1;
        zoomState.translateX = 0;
        zoomState.translateY = 0;
        applyTransform();
      }

      function easeOutCubic(value) {
        return 1 - Math.pow(1 - value, 3);
      }

      let activeAnimationToken = 0;

      function animateTransform(target, durationMs, onComplete) {
        const start = {
          scale: zoomState.scale,
          translateX: zoomState.translateX,
          translateY: zoomState.translateY,
        };
        const startTime = performance.now();
        const token = activeAnimationToken + 1;
        activeAnimationToken = token;
        const duration = Math.max(1, durationMs || 1);

        function step(now) {
          if (token !== activeAnimationToken) {
            return;
          }
          const elapsed = now - startTime;
          const t = Math.min(elapsed / duration, 1);
          const eased = easeOutCubic(t);
          zoomState.scale = start.scale + (target.scale - start.scale) * eased;
          zoomState.translateX =
            start.translateX + (target.translateX - start.translateX) * eased;
          zoomState.translateY =
            start.translateY + (target.translateY - start.translateY) * eased;
          applyTransform();
          if (t < 1) {
            requestAnimationFrame(step);
            return;
          }
          if (onComplete) {
            onComplete();
          }
        }

        requestAnimationFrame(step);
      }

      function animateSearchFocus() {
        const target = { scale: 1, translateX: 0, translateY: 0 };
        const atRest =
          Math.abs(zoomState.scale - target.scale) < 0.01 &&
          Math.abs(zoomState.translateX - target.translateX) < 1 &&
          Math.abs(zoomState.translateY - target.translateY) < 1;
        if (atRest) {
          const pulseScale = Math.min(zoomConfig.max, 1.12);
          animateTransform(
            { scale: pulseScale, translateX: 0, translateY: 0 },
            180,
            () => {
              animateTransform(target, 240);
            }
          );
          return;
        }
        animateTransform(target, 420);
      }

      function clampScale(value) {
        return Math.min(Math.max(value, zoomConfig.min), zoomConfig.max);
      }

      function zoomTo(targetScale, focusPoint, viewBox) {
        const newScale = clampScale(targetScale);
        const focal = focusPoint || { x: viewBox.width / 2, y: viewBox.height / 2 };
        const oldScale = zoomState.scale;
        zoomState.translateX =
          zoomState.translateX + focal.x / newScale - focal.x / oldScale;
        zoomState.translateY =
          zoomState.translateY + focal.y / newScale - focal.y / oldScale;
        zoomState.scale = newScale;
        applyTransform();
      }

      function clientToSvg(event, viewBox) {
        const rect = mapSvg.getBoundingClientRect();
        const x = ((event.clientX - rect.left) / rect.width) * viewBox.width;
        const y = ((event.clientY - rect.top) / rect.height) * viewBox.height;
        return { x, y };
      }

      function showTooltip(title, lines, event) {
        tooltip.innerHTML = "";
        const strong = document.createElement("strong");
        strong.textContent = title;
        tooltip.appendChild(strong);
        lines.forEach((line) => {
          const div = document.createElement("div");
          div.textContent = line;
          tooltip.appendChild(div);
        });
        tooltip.style.opacity = "1";
        tooltip.style.transform = "translateY(0)";
        const rect = tooltip.getBoundingClientRect();
        const offsetX = event.clientX + 16;
        const offsetY = event.clientY + 16;
        tooltip.style.left = `${offsetX}px`;
        tooltip.style.top = `${offsetY}px`;
        if (offsetX + rect.width > window.innerWidth) {
          tooltip.style.left = `${event.clientX - rect.width - 16}px`;
        }
      }

      function hideTooltip() {
        tooltip.style.opacity = "0";
        tooltip.style.transform = "translateY(8px)";
      }

      function packageDisplayName(pkg) {
        if (!pkg) {
          return "";
        }
        if (pkg.id === "") {
          return activeLabels.defaultPackage;
        }
        return pkg.id;
      }

      function packageShortLabel(pkg) {
        if (!pkg) {
          return "";
        }
        if (pkg.shortName && pkg.shortName.trim()) {
          return pkg.shortName;
        }
        return packageDisplayName(pkg);
      }

      function formatPackageName(name) {
        if (name === "") {
          return activeLabels.defaultPackage;
        }
        if (name === null || name === undefined) {
          return "-";
        }
        return name;
      }

      function truncateLabel(value, maxLength) {
        if (!value) {
          return "";
        }
        if (value.length <= maxLength) {
          return value;
        }
        return `${value.slice(0, Math.max(0, maxLength - 3))}...`;
      }

      function clampValue(value, min, max) {
        return Math.min(Math.max(value, min), max);
      }

      function resolveLabelFit(text, width, height) {
        const fontSize = clampValue(height * 0.18, 6, 10);
        const padding = Math.max(6, fontSize * 0.7);
        const available = Math.max(0, width - padding * 2);
        const avgCharWidth = fontSize * 0.58;
        const maxChars = Math.floor(available / avgCharWidth);
        if (maxChars < 4) {
          return { text: "", fontSize, offsetY: Math.max(3, fontSize * 0.35) };
        }
        return {
          text: truncateLabel(text, maxChars),
          fontSize,
          offsetY: Math.max(3, fontSize * 0.35),
        };
      }

      function resolveCircleLabelFit(text, minDiameter) {
        const fontSize = clampValue(minDiameter * 0.18, 7, 11);
        const padding = Math.max(4, fontSize * 0.7);
        const avgCharWidth = fontSize * 0.55;
        const requiredDiameter = Math.max(
          minDiameter,
          text.length * avgCharWidth + padding * 2
        );
        return {
          text,
          fontSize,
          offsetY: Math.max(3, fontSize * 0.35),
          radius: requiredDiameter / 2,
        };
      }

      function resolveBelowLabelFit(text, width) {
        const fontSize = clampValue(width * 0.08, 9, 12);
        const avgCharWidth = fontSize * 0.56;
        const maxWidth = Math.min(200, Math.max(width * 2.1, 120));
        const maxChars = Math.max(6, Math.floor(maxWidth / avgCharWidth));
        return {
          text: truncateLabel(text, maxChars),
          fontSize,
          offsetY: fontSize + 8,
        };
      }

      function formatCount(value) {
        return Number.isFinite(value) ? String(value) : "-";
      }

      function formatDecimal(value, digits) {
        if (!Number.isFinite(value)) {
          return "-";
        }
        return value.toFixed(digits);
      }

      function formatCoverage(value) {
        if (!Number.isFinite(value)) {
          return "-";
        }
        const clamped = Math.min(Math.max(value, 0), 100);
        return `${formatDecimal(clamped, 1)}%`;
      }

      function sortDetailClasses(classList) {
        return classList
          .slice()
          .sort((a, b) => {
            const complexityDiff = (b?.complexityMax || 0) - (a?.complexityMax || 0);
            if (complexityDiff !== 0) {
              return complexityDiff;
            }
            return (a?.id || "").localeCompare(b?.id || "");
          });
      }

      function buildClassDetailLinks(classList) {
        return sortDetailClasses(classList)
          .filter((classInfo) => classInfo && classInfo.detailLink)
          .map((classInfo) => ({
            label: classInfo.id || classInfo.simpleName || classInfo.detailLink,
            href: classInfo.detailLink,
          }));
      }

      function belongsToFile(classInfo, fileId) {
        if (!classInfo || !fileId) {
          return false;
        }
        if (classInfo.filePath) {
          return classInfo.filePath === fileId;
        }
        const file = fileById.get(fileId);
        if (!file || !file.name || !classInfo.id) {
          return false;
        }
        const typeName = file.name.endsWith(".java") ? file.name.slice(0, -5) : file.name;
        const packagePrefix = file.packageName ? `${file.packageName}.` : "";
        const expectedPrefix = `${packagePrefix}${typeName}`;
        return classInfo.id === expectedPrefix || classInfo.id.startsWith(`${expectedPrefix}.`);
      }

      function buildDetailLinksForFile(fileId) {
        return buildClassDetailLinks(classes.filter((classInfo) => belongsToFile(classInfo, fileId)));
      }

      function buildDetailLinksForPackage(packageId) {
        if (packageId === null || packageId === undefined) {
          return [];
        }
        return buildClassDetailLinks(
          classes.filter((classInfo) => {
            if (!classInfo || !classInfo.packageName) {
              return false;
            }
            if (classInfo.packageName === packageId) {
              return true;
            }
            return packageId !== "" && classInfo.packageName.startsWith(`${packageId}.`);
          })
        );
      }

      function layoutRing(nodes, radius, center, jitterSeed) {
        const positions = new Map();
        if (!nodes.length) {
          return positions;
        }
        const step = (Math.PI * 2) / nodes.length;
        nodes.forEach((node, index) => {
          const angle = step * index - Math.PI / 2;
          const jitter = (index % 2 === 0 ? 1 : -1) * 6;
          const x = center.x + (radius + jitter) * Math.cos(angle + jitterSeed * 0.1);
          const y = center.y + (radius + jitter) * Math.sin(angle + jitterSeed * 0.1);
          positions.set(node.id, { x, y });
        });
        return positions;
      }

      function buildExternalContext(edges, focusIds) {
        if (!focusIds || focusIds.size === 0) {
          return { nodes: [], edges: [] };
        }
        const scopedEdges = edges.filter((edge) => focusIds.has(edge.from));
        if (!scopedEdges.length) {
          return { nodes: [], edges: [] };
        }
        const perFrom = new Map();
        const totals = new Map();
        scopedEdges.forEach((edge) => {
          if (!perFrom.has(edge.from)) {
            perFrom.set(edge.from, []);
          }
          perFrom.get(edge.from).push(edge);
          totals.set(edge.to, (totals.get(edge.to) || 0) + edge.weight);
        });
        perFrom.forEach((list) => list.sort((a, b) => b.weight - a.weight));

        const selected = new Set();
        perFrom.forEach((list) => {
          if (list.length) {
            selected.add(list[0].to);
          }
        });

        const targetLimit = Math.min(
          externalNodeLimitMax,
          Math.max(externalNodeLimitBase, focusIds.size)
        );
        let remaining = Math.max(0, targetLimit - selected.size);
        const sortedExternal = Array.from(totals.entries())
          .sort((a, b) => {
            if (b[1] !== a[1]) {
              return b[1] - a[1];
            }
            return a[0].localeCompare(b[0]);
          })
          .map(([id]) => id);
        for (const externalId of sortedExternal) {
          if (selected.has(externalId)) {
            continue;
          }
          if (remaining <= 0) {
            break;
          }
          selected.add(externalId);
          remaining -= 1;
        }

        const nodes = Array.from(selected)
          .map((id) => ({ id, weight: totals.get(id) || 0 }))
          .sort((a, b) => {
            if (b.weight !== a.weight) {
              return b.weight - a.weight;
            }
            return a.id.localeCompare(b.id);
          });
        const edgesToShow = scopedEdges.filter((edge) => selected.has(edge.to));
        return { nodes, edges: edgesToShow };
      }

      function renderExternalLayer(edges, focusIds, nodePositions, center, radius, jitterSeed) {
        const context = buildExternalContext(edges, focusIds);
        if (!context.nodes.length) {
          return null;
        }
        const minDiameter = 48;
        const labelLayouts = new Map();
        let maxRadius = minDiameter / 2;
        context.nodes.forEach((node) => {
          const layout = resolveCircleLabelFit(node.id, minDiameter);
          labelLayouts.set(node.id, layout);
          if (layout.radius > maxRadius) {
            maxRadius = layout.radius;
          }
        });
        const positions = layoutRing(
          context.nodes,
          radius + (maxRadius - minDiameter / 2),
          center,
          jitterSeed
        );
        const edgeGroup = createSvgElement("g", {});
        context.edges.forEach((edge) => {
          const from = nodePositions.get(edge.from);
          const to = positions.get(edge.to);
          if (!from || !to) {
            return;
          }
          const path = createSvgElement("path", {
            d: `M ${from.x} ${from.y} L ${to.x} ${to.y}`,
            class: "edge external-edge",
          });
          edgeGroup.appendChild(path);
        });

        const nodesGroup = createSvgElement("g", {});
        context.nodes.forEach((node) => {
          const position = positions.get(node.id);
          if (!position) {
            return;
          }
          const labelFit = labelLayouts.get(node.id);
          const radiusValue = labelFit ? labelFit.radius : minDiameter / 2;
          const group = createSvgElement("g", { class: "external-node" });
          const circle = createSvgElement("circle", {
            cx: position.x,
            cy: position.y,
            r: radiusValue,
          });
          const label = createSvgElement("text", {
            x: position.x,
            y: position.y + (labelFit ? labelFit.offsetY : 0),
          });
          label.textContent = labelFit ? labelFit.text : node.id;
          if (labelFit) {
            label.style.fontSize = `${labelFit.fontSize}px`;
          }
          group.appendChild(circle);
          group.appendChild(label);
          group.addEventListener("mouseenter", (event) => {
            showTooltip(node.id, [activeLabels.externalDependency], event);
          });
          group.addEventListener("mouseleave", hideTooltip);
          nodesGroup.appendChild(group);
        });
        return { edgeGroup, nodesGroup };
      }

      function renderEmptyState(viewBox) {
        const text = createSvgElement("text", {
          x: viewBox.width / 2,
          y: viewBox.height / 2,
          "text-anchor": "middle",
          fill: "#6b7280",
          "font-size": "14",
        });
        text.textContent = activeLabels.emptyNodes;
        mapSvg.appendChild(text);
      }

      function renderMap() {
        while (mapSvg.firstChild) {
          mapSvg.removeChild(mapSvg.firstChild);
        }
        mapLayer = null;

        const rect = mapSvg.getBoundingClientRect();
        const width = rect.width || 900;
        const height = rect.height || 600;
        const viewBox = { width, height };
        mapSvg.setAttribute("viewBox", `0 0 ${width} ${height}`);

        const center = { x: width / 2, y: height / 2 };
        const ringBase = Math.min(width, height);

        if (state.level === 0) {
          if (
            state.selectedPackageId === null ||
            state.selectedPackageId === undefined ||
            !packageById.has(state.selectedPackageId)
          ) {
            const topPackage = getTopNode(packages, packageScores);
            state.selectedPackageId = topPackage ? topPackage.id : null;
          }

          if (state.selectedPackageId === null || state.selectedPackageId === undefined) {
            renderEmptyState(viewBox);
            return;
          }

          const focusId = state.selectedPackageId;
          const hopDistances = resolveHopDistances(packageAdjacency, focusId, 2);
          const displayNodes = packages.filter(
            (pkg) => pkg.id === focusId || hopDistances.has(pkg.id)
          );
          const displayIds = new Set(displayNodes.map((node) => node.id));
          const displayEdges = packageEdges.filter(
            (edge) => displayIds.has(edge.from) && displayIds.has(edge.to)
          );

          const ring1Nodes = displayNodes.filter((node) => hopDistances.get(node.id) === 1);
          const ring2Nodes = displayNodes.filter((node) => hopDistances.get(node.id) === 2);
          ring1Nodes.sort(
            (a, b) =>
              (packageScores.get(b.id).edgeWeight || 0) -
              (packageScores.get(a.id).edgeWeight || 0)
          );
          ring2Nodes.sort(
            (a, b) =>
              packageScores.get(b.id).leverageScore - packageScores.get(a.id).leverageScore
          );

          const positions = new Map();
          positions.set(focusId, { x: center.x, y: center.y });

          const ring1Radius = ringBase * 0.22;
          const ring2Radius = ringBase * 0.36;
          layoutRing(ring1Nodes, ring1Radius, center, 0.4).forEach((value, key) => {
            positions.set(key, value);
          });
          layoutRing(ring2Nodes, ring2Radius, center, 0.8).forEach((value, key) => {
            positions.set(key, value);
          });

          const edgesGroup = createSvgElement("g", {});
          displayEdges.forEach((edge) => {
            const from = positions.get(edge.from);
            const to = positions.get(edge.to);
            if (!from || !to) {
              return;
            }
            const path = createSvgElement("path", {
              d: `M ${from.x} ${from.y} L ${to.x} ${to.y}`,
              class: `edge${edge.from === focusId || edge.to === focusId ? " edge-focus" : ""}`,
            });
            edgesGroup.appendChild(path);
          });

          const nodesGroup = createSvgElement("g", {});
          displayNodes.forEach((pkg, index) => {
            const position = positions.get(pkg.id);
            if (!position) {
              return;
            }
            const score = packageScores.get(pkg.id);
            const size = 96 + score.impactScore * 110;
            const width = size * 1.4;
            const height = size * 0.7;
            const labelFit = resolveLabelFit(packageShortLabel(pkg), width, height);
            const group = createSvgElement("g", {
              class: `map-node node-score-${score.level.toLowerCase()}${
                pkg.id === focusId ? " node-selected" : ""
              }`,
            });
            group.setAttribute("data-id", pkg.id);
            group.setAttribute("data-type", "package");
            group.style.animation = `fadeRise 400ms ease ${index * 40}ms both`;

            const rectNode = createSvgElement("rect", {
              x: position.x - width / 2,
              y: position.y - height / 2,
              width,
              height,
              rx: 14,
              ry: 14,
            });
            const label = createSvgElement("text", {
              x: position.x,
              y: position.y + labelFit.offsetY,
            });
            label.textContent = labelFit.text;
            label.style.fontSize = `${labelFit.fontSize}px`;

            group.appendChild(rectNode);
            group.appendChild(label);
            group.addEventListener("mouseenter", (event) => {
              showTooltip(packageDisplayName(pkg), [`Leverage: ${score.level}`], event);
            });
            group.addEventListener("mouseleave", hideTooltip);
            group.addEventListener("click", (event) => {
              event.stopPropagation();
              state.selectedPackageId = pkg.id;
              resetZoom();
              renderAll();
            });
            group.addEventListener("dblclick", (event) => {
              event.stopPropagation();
              state.level = 1;
              state.selectedPackageId = pkg.id;
              state.selectedFileId = null;
              resetZoom();
              renderAll();
            });
            nodesGroup.appendChild(group);
          });

          const externalLayer = renderExternalLayer(
            externalEdges,
            displayIds,
            positions,
            center,
            ringBase * 0.48,
            1.1
          );

          mapLayer = createSvgElement("g", {});
          mapLayer.appendChild(edgesGroup);
          if (externalLayer) {
            mapLayer.appendChild(externalLayer.edgeGroup);
          }
          mapLayer.appendChild(nodesGroup);
          if (externalLayer) {
            mapLayer.appendChild(externalLayer.nodesGroup);
          }

          mapSvg.appendChild(mapLayer);
          applyTransform();
          return;
        }

        if (state.level === 1 || state.level === 2) {
          if (
            state.selectedPackageId === null ||
            state.selectedPackageId === undefined ||
            !packageById.has(state.selectedPackageId)
          ) {
            const topPackage = getTopNode(packages, packageScores);
            state.selectedPackageId = topPackage ? topPackage.id : null;
          }
          const { scopedFiles, scopedEdges, scopedAdjacency } = buildFileContext(
            state.selectedPackageId
          );
          if (!scopedFiles.length) {
            renderEmptyState(viewBox);
            return;
          }

          const scopedFileIds = new Set(scopedFiles.map((file) => file.id));
          if (!state.selectedFileId || !scopedFileIds.has(state.selectedFileId)) {
            const topFile = getTopNode(scopedFiles, fileScores);
            state.selectedFileId = topFile ? topFile.id : null;
          }
          const focusId = state.selectedFileId;
          const maxHop = state.level === 2 ? 1 : 2;
          const hopDistances = resolveHopDistances(scopedAdjacency, focusId, maxHop);
          const displayNodes = scopedFiles.filter(
            (file) => file.id === focusId || hopDistances.has(file.id)
          );
          const displayIds = new Set(displayNodes.map((node) => node.id));
          const displayEdges = scopedEdges.filter(
            (edge) => displayIds.has(edge.from) && displayIds.has(edge.to)
          );

          const ring1Nodes = displayNodes.filter((node) => hopDistances.get(node.id) === 1);
          const ring2Nodes = displayNodes.filter((node) => hopDistances.get(node.id) === 2);
          ring1Nodes.sort(
            (a, b) =>
              (fileScores.get(b.id).edgeWeight || 0) - (fileScores.get(a.id).edgeWeight || 0)
          );
          ring2Nodes.sort(
            (a, b) => fileScores.get(b.id).leverageScore - fileScores.get(a.id).leverageScore
          );

          const positions = new Map();
          positions.set(focusId, { x: center.x, y: center.y });

          const ring1Radius = ringBase * 0.2;
          const ring2Radius = ringBase * 0.32;
          layoutRing(ring1Nodes, ring1Radius, center, 0.3).forEach((value, key) => {
            positions.set(key, value);
          });
          layoutRing(ring2Nodes, ring2Radius, center, 0.6).forEach((value, key) => {
            positions.set(key, value);
          });

          const edgesGroup = createSvgElement("g", {});
          displayEdges.forEach((edge) => {
            const from = positions.get(edge.from);
            const to = positions.get(edge.to);
            if (!from || !to) {
              return;
            }
            const path = createSvgElement("path", {
              d: `M ${from.x} ${from.y} L ${to.x} ${to.y}`,
              class: `edge${edge.from === focusId || edge.to === focusId ? " edge-focus" : ""}`,
            });
            edgesGroup.appendChild(path);
          });

          const nodesGroup = createSvgElement("g", {});
          displayNodes.forEach((file, index) => {
            const position = positions.get(file.id);
            if (!position) {
              return;
            }
            const score = fileScores.get(file.id);
            const size = 84 + score.impactScore * 90;
            const width = size * 1.5;
            const height = size * 0.7;
            const labelFit = resolveLabelFit(file.name, width, height);
            const group = createSvgElement("g", {
              class: `map-node node-score-${score.level.toLowerCase()}${
                file.id === focusId ? " node-selected" : ""
              }`,
            });
            group.setAttribute("data-id", file.id);
            group.setAttribute("data-type", "file");
            group.style.animation = `fadeRise 400ms ease ${index * 40}ms both`;

            const rectNode = createSvgElement("rect", {
              x: position.x - width / 2,
              y: position.y - height / 2,
              width,
              height,
              rx: 12,
              ry: 12,
            });
            const label = createSvgElement("text", {
              x: position.x,
              y: position.y + labelFit.offsetY,
            });
            label.textContent = labelFit.text;
            label.style.fontSize = `${labelFit.fontSize}px`;

            group.appendChild(rectNode);
            group.appendChild(label);
            group.addEventListener("mouseenter", (event) => {
              showTooltip(file.name, [`Leverage: ${score.level}`], event);
            });
            group.addEventListener("mouseleave", hideTooltip);
            group.addEventListener("click", (event) => {
              event.stopPropagation();
              state.selectedFileId = file.id;
              resetZoom();
              renderAll();
            });
            group.addEventListener("dblclick", (event) => {
              if (state.level === 1) {
                event.stopPropagation();
                state.level = 2;
                state.selectedFileId = file.id;
                resetZoom();
                renderAll();
              }
            });
            nodesGroup.appendChild(group);
          });

          const externalLayer = renderExternalLayer(
            fileExternalEdges,
            displayIds,
            positions,
            center,
            ringBase * 0.42,
            0.9
          );

          mapLayer = createSvgElement("g", {});
          mapLayer.appendChild(edgesGroup);
          if (externalLayer) {
            mapLayer.appendChild(externalLayer.edgeGroup);
          }
          mapLayer.appendChild(nodesGroup);
          if (externalLayer) {
            mapLayer.appendChild(externalLayer.nodesGroup);
          }
          mapSvg.appendChild(mapLayer);
          applyTransform();
        }
      }

      function buildSelection() {
        if (state.level === 0) {
          if (
            state.selectedPackageId === null ||
            state.selectedPackageId === undefined ||
            !packageById.has(state.selectedPackageId)
          ) {
            return null;
          }
          const pkg = packageById.get(state.selectedPackageId);
          const score = packageScores.get(pkg.id) || {
            level: "Low",
            impactScore: 0,
            complexityScore: 0,
          };
          const adjacency = packageAdjacency.get(pkg.id) || new Map();
          const internalConnections = Array.from(adjacency.entries())
            .sort((a, b) => b[1] - a[1])
            .map(([id]) => {
              const target = packageById.get(id);
              const targetScore = packageScores.get(id) || { level: "Low" };
              return {
                label: target ? packageShortLabel(target) : id,
                score: targetScore,
              };
            });
          const externalConnections = buildExternalConnections(
            externalEdges,
            pkg.id,
            detailExternalLimit
          );
          const connections = internalConnections
            .slice(0, Math.max(0, detailConnectionLimit - externalConnections.length))
            .concat(externalConnections);
          const metrics = [
            { label: "Classes", value: formatCount(pkg.classCount) },
            { label: "Methods", value: formatCount(pkg.methodCount) },
            { label: "LOC", value: formatCount(pkg.loc) },
            { label: "Complexity Max", value: formatCount(pkg.complexityMax) },
            { label: "Coverage", value: formatCoverage(pkg.lineCoverage) },
          ];
          return {
            type: "Package",
            name: packageDisplayName(pkg),
            score,
            reasons: buildReasons(score),
            metrics,
            detailLinks: buildDetailLinksForPackage(pkg.id),
            connections,
          };
        }

        if (state.selectedFileId && fileById.has(state.selectedFileId)) {
          const file = fileById.get(state.selectedFileId);
          const score = fileScores.get(file.id) || {
            level: "Low",
            impactScore: 0,
            complexityScore: 0,
          };
          const { scopedAdjacency } = buildFileContext(state.selectedPackageId);
          const adjacency = scopedAdjacency.get(file.id) || new Map();
          const internalConnections = Array.from(adjacency.entries())
            .sort((a, b) => b[1] - a[1])
            .map(([id]) => {
              const target = fileById.get(id);
              const targetScore = fileScores.get(id) || { level: "Low" };
              return {
                label: target ? target.name : id,
                score: targetScore,
              };
            });
          const externalConnections = buildExternalConnections(
            fileExternalEdges,
            file.id,
            detailExternalLimit
          );
          const connections = internalConnections
            .slice(0, Math.max(0, detailConnectionLimit - externalConnections.length))
            .concat(externalConnections);
          const metrics = [
            { label: "Package", value: formatPackageName(file.packageName) },
            { label: "LOC", value: formatCount(file.loc) },
            { label: "Methods", value: formatCount(file.methodCount) },
            { label: "Complexity Max", value: formatCount(file.complexityMax) },
            { label: "Coverage", value: formatCoverage(file.lineCoverage) },
          ];
          return {
            type: "File",
            name: file.name,
            score,
            reasons: buildReasons(score),
            metrics,
            detailLinks: buildDetailLinksForFile(file.id),
            connections,
          };
        }
        return null;
      }

      function renderAll() {
        updateBreadcrumbs();
        if (state.level === 0) {
          updateDashboard(packages, packageScores);
        } else {
          const scopedFiles = filterFilesForPackage(state.selectedPackageId);
          updateDashboard(scopedFiles, fileScores);
        }
        renderMap();
        updateDetailPanel(buildSelection());
        updateTreeSelection();
      }

      function bindMapControls() {
        const controls = document.getElementById("map-controls");
        if (!controls) {
          return;
        }
        controls.addEventListener("click", (event) => {
          const button = event.target.closest("button");
          if (!button) {
            return;
          }
          const rect = mapSvg.getBoundingClientRect();
          const viewBox = { width: rect.width || 900, height: rect.height || 600 };
          const focusPoint = { x: viewBox.width / 2, y: viewBox.height / 2 };
          const action = button.dataset.action;
          if (action === "zoom-in") {
            zoomTo(zoomState.scale * zoomConfig.step, focusPoint, viewBox);
          } else if (action === "zoom-out") {
            zoomTo(zoomState.scale / zoomConfig.step, focusPoint, viewBox);
          } else if (action === "reset") {
            resetZoom();
          }
        });
      }

      function bindPanZoom() {
        mapSvg.addEventListener(
          "wheel",
          (event) => {
            event.preventDefault();
            const rect = mapSvg.getBoundingClientRect();
            const viewBox = { width: rect.width || 900, height: rect.height || 600 };
            const focusPoint = clientToSvg(event, viewBox);
            const direction = event.deltaY < 0 ? zoomConfig.step : 1 / zoomConfig.step;
            zoomTo(zoomState.scale * direction, focusPoint, viewBox);
          },
          { passive: false }
        );

        mapSvg.addEventListener("pointerdown", (event) => {
          if (event.button !== 0) {
            return;
          }
          if (event.target.closest(".map-node")) {
            return;
          }
          isDragging = true;
          dragStart = { x: event.clientX, y: event.clientY };
          mapSvg.classList.add("grabbing");
          mapSvg.setPointerCapture(event.pointerId);
        });

        mapSvg.addEventListener("pointermove", (event) => {
          if (!isDragging || !dragStart) {
            return;
          }
          const dx = (event.clientX - dragStart.x) / zoomState.scale;
          const dy = (event.clientY - dragStart.y) / zoomState.scale;
          zoomState.translateX += dx;
          zoomState.translateY += dy;
          dragStart = { x: event.clientX, y: event.clientY };
          applyTransform();
        });

        mapSvg.addEventListener("pointerup", () => {
          isDragging = false;
          dragStart = null;
          mapSvg.classList.remove("grabbing");
        });

        mapSvg.addEventListener("pointerleave", () => {
          isDragging = false;
          dragStart = null;
          mapSvg.classList.remove("grabbing");
        });
      }

      function renderSearchResults(query) {
        const normalized = query.trim().toLowerCase();
        let results = searchIndex;
        if (normalized) {
          results = searchIndex.filter((item) => item.searchKey.includes(normalized));
        }
        results = results
          .slice()
          .sort((a, b) => b.scoreValue - a.scoreValue)
          .slice(0, 12);

        paletteResults.innerHTML = "";
        if (!results.length) {
          const empty = document.createElement("div");
          empty.className = "palette-empty";
          empty.textContent = activeLabels.noMatches;
          paletteResults.appendChild(empty);
          return [];
        }

        results.forEach((item, index) => {
          const row = document.createElement("div");
          row.className = "palette-item";
          if (index === 0) {
            row.classList.add("is-active");
          }
          row.dataset.index = index;
          const title = document.createElement("div");
          title.className = "palette-title";
          title.textContent = item.name;
          const meta = document.createElement("div");
          meta.className = "palette-meta";
          const type = document.createElement("span");
          type.textContent = activeLabels.types[item.type] || item.type;
          const score = document.createElement("span");
          score.className = `palette-score ${toScoreClass(item.scoreLabel)}`;
          score.textContent = item.scoreLabel;
          meta.appendChild(type);
          meta.appendChild(score);
          row.appendChild(title);
          row.appendChild(meta);
          row.addEventListener("click", () => selectSearchItem(item));
          paletteResults.appendChild(row);
        });
        return results;
      }

      let activeSearchResults = [];

      function openPalette() {
        palette.classList.remove("is-hidden");
        paletteInput.value = "";
        activeSearchResults = renderSearchResults("");
        paletteInput.focus();
      }

      function closePalette() {
        palette.classList.add("is-hidden");
      }

      function selectSearchItem(item) {
        if (item.type === "Package") {
          state.level = 0;
          state.selectedPackageId = item.id;
          state.selectedFileId = null;
        } else {
          state.level = 2;
          state.selectedFileId = item.id;
          state.selectedPackageId = item.packageName;
        }
        setActiveTab("visual", false);
        requestAnimationFrame(() => {
          animateSearchFocus();
        });
        closePalette();
      }

      function bindSearchPalette() {
        document.addEventListener("keydown", (event) => {
          const isMeta = event.metaKey || event.ctrlKey;
          if (isMeta && event.key.toLowerCase() === "k") {
            event.preventDefault();
            if (palette.classList.contains("is-hidden")) {
              openPalette();
            } else {
              closePalette();
            }
          }
          if (event.key === "Escape" && !palette.classList.contains("is-hidden")) {
            closePalette();
          }
        });

        paletteInput.addEventListener("input", (event) => {
          activeSearchResults = renderSearchResults(event.target.value);
        });

        paletteInput.addEventListener("keydown", (event) => {
          if (!activeSearchResults.length) {
            return;
          }
          const current = paletteResults.querySelector(".palette-item.is-active");
          let index = current ? Number(current.dataset.index) : 0;
          if (event.key === "ArrowDown") {
            event.preventDefault();
            index = (index + 1) % activeSearchResults.length;
          }
          if (event.key === "ArrowUp") {
            event.preventDefault();
            index = (index - 1 + activeSearchResults.length) % activeSearchResults.length;
          }
          if (event.key === "Enter") {
            event.preventDefault();
            const item = activeSearchResults[index];
            if (item) {
              selectSearchItem(item);
            }
          }
          const rows = paletteResults.querySelectorAll(".palette-item");
          rows.forEach((row) => row.classList.remove("is-active"));
          if (rows[index]) {
            rows[index].classList.add("is-active");
          }
        });

        paletteBackdrop.addEventListener("click", closePalette);
      }

      function init() {
        applyThemeSelection(uiConfig.currentTheme);
        applyLabels(activeLabels);
        bindSettingsControls();
        bindWorkspaceTabs();
        buildSourceTree();
        bindSourceTree();
        bindMapControls();
        bindPanZoom();
        bindSearchPalette();
        setActiveTab("visual", false);
        window.addEventListener("resize", () => {
          if (state.activeTab === "visual") {
            renderAll();
          }
        });
      }

      init();
    </script>
  </body>
</html>
